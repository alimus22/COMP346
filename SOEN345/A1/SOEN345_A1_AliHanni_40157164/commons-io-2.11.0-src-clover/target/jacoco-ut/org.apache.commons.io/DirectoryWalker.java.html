<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirectoryWalker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons IO</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.io</a> &gt; <span class="el_source">DirectoryWalker.java</span></div><h1>DirectoryWalker.java</h1><pre class="source lang-java linenums">/* $$ This file has been instrumented by Clover 4.4.1#2019101123313948 $$ *//*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.io;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Collection;
import java.util.Objects;

import org.apache.commons.io.file.PathUtils;
import org.apache.commons.io.filefilter.FileFilterUtils;
import org.apache.commons.io.filefilter.IOFileFilter;
import org.apache.commons.io.filefilter.TrueFileFilter;

/**
 * Abstract class that walks through a directory hierarchy and provides subclasses with convenient hooks to add specific
 * behavior.
 * &lt;p&gt;
 * This class operates with a {@link FileFilter} and maximum depth to limit the files and directories visited. Commons
 * IO supplies many common filter implementations in the &lt;a href=&quot;filefilter/package-summary.html&quot;&gt; filefilter&lt;/a&gt;
 * package.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The following sections describe:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href=&quot;#example&quot;&gt;1. Example Implementation&lt;/a&gt; - example {@code FileCleaner} implementation.&lt;/li&gt;
 * &lt;li&gt;&lt;a href=&quot;#filter&quot;&gt;2. Filter Example&lt;/a&gt; - using {@link FileFilter}(s) with {@code DirectoryWalker}.&lt;/li&gt;
 * &lt;li&gt;&lt;a href=&quot;#cancel&quot;&gt;3. Cancellation&lt;/a&gt; - how to implement cancellation behavior.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h2 id=&quot;example&quot;&gt;1. Example Implementation&lt;/h2&gt;
 *
 * There are many possible extensions, for example, to delete all files and '.svn' directories, and return a list of
 * deleted files:
 *
 * &lt;pre&gt;
 * public class FileCleaner extends DirectoryWalker {
 *
 *     public FileCleaner() {
 *         super();
 *     }
 *
 *     public List clean(File startDirectory) {
 *         List results = new ArrayList();
 *         walk(startDirectory, results);
 *         return results;
 *     }
 *
 *     protected boolean handleDirectory(File directory, int depth, Collection results) {
 *         // delete svn directories and then skip
 *         if (&quot;.svn&quot;.equals(directory.getName())) {
 *             directory.delete();
 *             return false;
 *         } else {
 *             return true;
 *         }
 *
 *     }
 *
 *     protected void handleFile(File file, int depth, Collection results) {
 *         // delete file and add to list of deleted
 *         file.delete();
 *         results.add(file);
 *     }
 * }
 * &lt;/pre&gt;
 *
 * &lt;h2 id=&quot;filter&quot;&gt;2. Filter Example&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Choosing which directories and files to process can be a key aspect of using this class. This information can be
 * setup in three ways, via three different constructors.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The first option is to visit all directories and files. This is achieved via the no-args constructor.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The second constructor option is to supply a single {@link FileFilter} that describes the files and directories to
 * visit. Care must be taken with this option as the same filter is used for both directories and files.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if you wanted all directories which are not hidden and files which end in &quot;.txt&quot;:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * public class FooDirectoryWalker extends DirectoryWalker {
 *     public FooDirectoryWalker(FileFilter filter) {
 *         super(filter, -1);
 *     }
 * }
 *
 * // Build up the filters and create the walker
 * // Create a filter for Non-hidden directories
 * IOFileFilter fooDirFilter = FileFilterUtils.andFileFilter(FileFilterUtils.directoryFileFilter,
 *     HiddenFileFilter.VISIBLE);
 *
 * // Create a filter for Files ending in &quot;.txt&quot;
 * IOFileFilter fooFileFilter = FileFilterUtils.andFileFilter(FileFilterUtils.fileFileFilter,
 *     FileFilterUtils.suffixFileFilter(&quot;.txt&quot;));
 *
 * // Combine the directory and file filters using an OR condition
 * java.io.FileFilter fooFilter = FileFilterUtils.orFileFilter(fooDirFilter, fooFileFilter);
 *
 * // Use the filter to construct a DirectoryWalker implementation
 * FooDirectoryWalker walker = new FooDirectoryWalker(fooFilter);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The third constructor option is to specify separate filters, one for directories and one for files. These are
 * combined internally to form the correct {@code FileFilter}, something which is very easy to get wrong when
 * attempted manually, particularly when trying to express constructs like 'any file in directories named docs'.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if you wanted all directories which are not hidden and files which end in &quot;.txt&quot;:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 *  public class FooDirectoryWalker extends DirectoryWalker {
 *    public FooDirectoryWalker(IOFileFilter dirFilter, IOFileFilter fileFilter) {
 *      super(dirFilter, fileFilter, -1);
 *    }
 *  }
 *
 *  // Use the filters to construct the walker
 *  FooDirectoryWalker walker = new FooDirectoryWalker(
 *    HiddenFileFilter.VISIBLE,
 *    FileFilterUtils.suffixFileFilter(&quot;.txt&quot;),
 *  );
 * &lt;/pre&gt;
 * &lt;p&gt;
 * This is much simpler than the previous example, and is why it is the preferred option for filtering.
 * &lt;/p&gt;
 *
 * &lt;h2 id=&quot;cancel&quot;&gt;3. Cancellation&lt;/h2&gt;
 *
 * &lt;p&gt;
 * The DirectoryWalker contains some of the logic required for cancel processing. Subclasses must complete the
 * implementation.
 * &lt;/p&gt;
 * &lt;p&gt;
 * What {@code DirectoryWalker} does provide for cancellation is:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link CancelException} which can be thrown in any of the &lt;i&gt;lifecycle&lt;/i&gt; methods to stop processing.&lt;/li&gt;
 * &lt;li&gt;The {@code walk()} method traps thrown {@link CancelException} and calls the {@code handleCancelled()}
 * method, providing a place for custom cancel processing.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Implementations need to provide:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;The decision logic on whether to cancel processing or not.&lt;/li&gt;
 * &lt;li&gt;Constructing and throwing a {@link CancelException}.&lt;/li&gt;
 * &lt;li&gt;Custom cancel processing in the {@code handleCancelled()} method.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Two possible scenarios are envisaged for cancellation:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href=&quot;#external&quot;&gt;3.1 External / Multi-threaded&lt;/a&gt; - cancellation being decided/initiated by an external
 * process.&lt;/li&gt;
 * &lt;li&gt;&lt;a href=&quot;#internal&quot;&gt;3.2 Internal&lt;/a&gt; - cancellation being decided/initiated from within a DirectoryWalker
 * implementation.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The following sections provide example implementations for these two different scenarios.
 * &lt;/p&gt;
 *
 * &lt;h3 id=&quot;external&quot;&gt;3.1 External / Multi-threaded&lt;/h3&gt;
 *
 * &lt;p&gt;
 * This example provides a public {@code cancel()} method that can be called by another thread to stop the
 * processing. A typical example use-case would be a cancel button on a GUI. Calling this method sets a
 * &lt;a href=&quot;http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#36930&quot;&gt; volatile&lt;/a&gt; flag to ensure
 * it will work properly in a multi-threaded environment. The flag is returned by the {@code handleIsCancelled()}
 * method, which will cause the walk to stop immediately. The {@code handleCancelled()} method will be the next,
 * and last, callback method received once cancellation has occurred.
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * public class FooDirectoryWalker extends DirectoryWalker {
 *
 *     private volatile boolean cancelled = false;
 *
 *     public void cancel() {
 *         cancelled = true;
 *     }
 *
 *     protected boolean handleIsCancelled(File file, int depth, Collection results) {
 *         return cancelled;
 *     }
 *
 *     protected void handleCancelled(File startDirectory, Collection results, CancelException cancel) {
 *         // implement processing required when a cancellation occurs
 *     }
 * }
 * &lt;/pre&gt;
 *
 * &lt;h3 id=&quot;internal&quot;&gt;3.2 Internal&lt;/h3&gt;
 *
 * &lt;p&gt;
 * This shows an example of how internal cancellation processing could be implemented. &lt;b&gt;Note&lt;/b&gt; the decision logic
 * and throwing a {@link CancelException} could be implemented in any of the &lt;i&gt;lifecycle&lt;/i&gt; methods.
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * public class BarDirectoryWalker extends DirectoryWalker {
 *
 *     protected boolean handleDirectory(File directory, int depth, Collection results) throws IOException {
 *         // cancel if hidden directory
 *         if (directory.isHidden()) {
 *             throw new CancelException(file, depth);
 *         }
 *         return true;
 *     }
 *
 *     protected void handleFile(File file, int depth, Collection results) throws IOException {
 *         // cancel if read-only file
 *         if (!file.canWrite()) {
 *             throw new CancelException(file, depth);
 *         }
 *         results.add(file);
 *     }
 *
 *     protected void handleCancelled(File startDirectory, Collection results, CancelException cancel) {
 *         // implement processing required when a cancellation occurs
 *     }
 * }
 * &lt;/pre&gt;
 *
 * @param &lt;T&gt; The result type, like {@link File}.
 * @since 1.3
 * @deprecated Apache Commons IO no longer uses this class. Instead, use
 *             {@link PathUtils#walk(java.nio.file.Path, org.apache.commons.io.file.PathFilter, int, boolean, java.nio.file.FileVisitOption...)}
 *             or {@link Files#walkFileTree(java.nio.file.Path, java.util.Set, int, java.nio.file.FileVisitor)}, and
 *             friends.
 */
@Deprecated
<span class="pc bpc" id="L255" title="3 of 4 branches missed.">public abstract class DirectoryWalker&lt;T&gt; {public static class __CLR4_4_14646kylvdyb4{public static com_atlassian_clover.CoverageRecorder R;public static com_atlassian_clover.CloverProfile[] profiles = { };@java.lang.SuppressWarnings(&quot;unchecked&quot;) public static &lt;I, T extends I&gt; I lambdaInc(final int i,final T l,final int si){java.lang.reflect.InvocationHandler h=new java.lang.reflect.InvocationHandler(){public java.lang.Object invoke(java.lang.Object p,java.lang.reflect.Method m,java.lang.Object[] a) throws Throwable{R.inc(i);R.inc(si);try{return m.invoke(l,a);}catch(java.lang.reflect.InvocationTargetException e){throw e.getCause()!=null?e.getCause():new RuntimeException(&quot;Clover failed to invoke instrumented lambda&quot;,e);}}};return (I)java.lang.reflect.Proxy.newProxyInstance(l.getClass().getClassLoader(),l.getClass().getInterfaces(),h);}static{com_atlassian_clover.CoverageRecorder _R=null;try{com_atlassian_clover.CloverVersionInfo.An_old_version_of_clover_is_on_your_compilation_classpath___Please_remove___Required_version_is___4_4_1();if(2019101123313948L!=com_atlassian_clover.CloverVersionInfo.getBuildStamp()){com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: The Clover version used in instrumentation does not match the runtime version. You need to run instrumented classes against the same version of Clover that you instrumented with.&quot;);com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: Instr=4.4.1#2019101123313948,Runtime=&quot;+com_atlassian_clover.CloverVersionInfo.getReleaseNum()+&quot;#&quot;+com_atlassian_clover.CloverVersionInfo.getBuildStamp());}R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getRecorder(&quot;\u002f\u0055\u0073\u0065\u0072\u0073\u002f\u0061\u006c\u0069\u0068\u0061\u006e\u006e\u0069\u002f\u0044\u0065\u0073\u006b\u0074\u006f\u0070\u002f\u0047\u0069\u0074\u0048\u0075\u0062\u002f\u0053\u004f\u0045\u004e\u002f\u0053\u004f\u0045\u004e\u0033\u0034\u0035\u002f\u0041\u0031\u002f\u0063\u006f\u006d\u006d\u006f\u006e\u0073\u002d\u0069\u006f\u002d\u0032\u002e\u0031\u0031\u002e\u0030\u002d\u0073\u0072\u0063\u002f\u0074\u0061\u0072\u0067\u0065\u0074\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002e\u0064\u0062&quot;,1642616389890L,8589935092L,235,profiles,new java.lang.String[]{&quot;clover.distributed.coverage&quot;,null});}catch(java.lang.SecurityException e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because it has insufficient security privileges. Please consult the Clover documentation on the security policy file changes required. (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.NoClassDefFoundError e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.Throwable t){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because of an unexpected error. (&quot;+t.getClass()+&quot;:&quot;+t.getMessage()+&quot;)&quot;);}R=_R;}}public static final com_atlassian_clover.TestNameSniffer __CLR4_4_1_TEST_NAME_SNIFFER=com_atlassian_clover.TestNameSniffer.NULL_INSTANCE;</span>

    /**
     * The file filter to use to filter files and directories.
     */
    private final FileFilter filter;
    /**
     * The limit on the directory depth to walk.
     */
    private final int depthLimit;

    /**
     * Construct an instance with no filtering and unlimited &lt;i&gt;depth&lt;/i&gt;.
     */
    protected DirectoryWalker() {
<span class="fc" id="L270">        this(null, -1);__CLR4_4_14646kylvdyb4.R.inc(151);try{__CLR4_4_14646kylvdyb4.R.inc(150);</span>
<span class="fc" id="L271">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Constructs an instance with a filter and limit the &lt;i&gt;depth&lt;/i&gt; navigated to.
     * &lt;p&gt;
     * The filter controls which files and directories will be navigated to as
     * part of the walk. The {@link FileFilterUtils} class is useful for combining
     * various filters together. A {@code null} filter means that no
     * filtering should occur and all files and directories will be visited.
     * &lt;/p&gt;
     *
     * @param filter  the filter to apply, null means visit all files
     * @param depthLimit  controls how &lt;i&gt;deep&lt;/i&gt; the hierarchy is
     *  navigated to (less than 0 means unlimited)
     */
<span class="fc" id="L286">    protected DirectoryWalker(final FileFilter filter, final int depthLimit) {try{__CLR4_4_14646kylvdyb4.R.inc(152);</span>
<span class="fc" id="L287">        __CLR4_4_14646kylvdyb4.R.inc(153);this.filter = filter;</span>
<span class="fc" id="L288">        __CLR4_4_14646kylvdyb4.R.inc(154);this.depthLimit = depthLimit;</span>
<span class="fc" id="L289">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Constructs an instance with a directory and a file filter and an optional
     * limit on the &lt;i&gt;depth&lt;/i&gt; navigated to.
     * &lt;p&gt;
     * The filters control which files and directories will be navigated to as part
     * of the walk. This constructor uses {@link FileFilterUtils#makeDirectoryOnly(IOFileFilter)}
     * and {@link FileFilterUtils#makeFileOnly(IOFileFilter)} internally to combine the filters.
     * A {@code null} filter means that no filtering should occur.
     * &lt;/p&gt;
     *
     * @param directoryFilter  the filter to apply to directories, null means visit all directories
     * @param fileFilter  the filter to apply to files, null means visit all files
     * @param depthLimit  controls how &lt;i&gt;deep&lt;/i&gt; the hierarchy is
     *  navigated to (less than 0 means unlimited)
     */
<span class="fc" id="L306">    protected DirectoryWalker(IOFileFilter directoryFilter, IOFileFilter fileFilter, final int depthLimit) {try{__CLR4_4_14646kylvdyb4.R.inc(155);</span>
<span class="pc bpc" id="L307" title="4 of 12 branches missed.">        __CLR4_4_14646kylvdyb4.R.inc(156);if ((((directoryFilter == null &amp;&amp; fileFilter == null)&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(157)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(158)==0&amp;false))) {{</span>
<span class="fc" id="L308">            __CLR4_4_14646kylvdyb4.R.inc(159);this.filter = null;</span>
        } }else {{
<span class="pc bpc" id="L310" title="4 of 10 branches missed.">            __CLR4_4_14646kylvdyb4.R.inc(160);directoryFilter = (((directoryFilter != null )&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(161)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(162)==0&amp;false))? directoryFilter : TrueFileFilter.TRUE;</span>
<span class="pc bpc" id="L311" title="4 of 10 branches missed.">            __CLR4_4_14646kylvdyb4.R.inc(163);fileFilter = (((fileFilter != null )&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(164)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(165)==0&amp;false))? fileFilter : TrueFileFilter.TRUE;</span>
<span class="fc" id="L312">            __CLR4_4_14646kylvdyb4.R.inc(166);directoryFilter = FileFilterUtils.makeDirectoryOnly(directoryFilter);</span>
<span class="fc" id="L313">            __CLR4_4_14646kylvdyb4.R.inc(167);fileFilter = FileFilterUtils.makeFileOnly(fileFilter);</span>
<span class="fc" id="L314">            __CLR4_4_14646kylvdyb4.R.inc(168);this.filter = directoryFilter.or(fileFilter);</span>
        }
<span class="fc" id="L316">        }__CLR4_4_14646kylvdyb4.R.inc(169);this.depthLimit = depthLimit;</span>
<span class="fc" id="L317">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Internal method that walks the directory hierarchy in a depth-first manner.
     * &lt;p&gt;
     * Users of this class do not need to call this method. This method will
     * be called automatically by another (public) method on the specific subclass.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Writers of subclasses should call this method to start the directory walk.
     * Once called, this method will emit events as it walks the hierarchy.
     * The event methods have the prefix {@code handle}.
     * &lt;/p&gt;
     *
     * @param startDirectory  the directory to start from, not null
     * @param results  the collection of result objects, may be updated
     * @throws NullPointerException if the start directory is null
     * @throws IOException if an I/O Error occurs
     */
<span class="fc" id="L336">    protected final void walk(final File startDirectory, final Collection&lt;T&gt; results) throws IOException {try{__CLR4_4_14646kylvdyb4.R.inc(170);</span>
<span class="fc" id="L337">        __CLR4_4_14646kylvdyb4.R.inc(171);Objects.requireNonNull(startDirectory, &quot;startDirectory&quot;);</span>
<span class="fc" id="L338">        __CLR4_4_14646kylvdyb4.R.inc(172);try {</span>
<span class="fc" id="L339">            __CLR4_4_14646kylvdyb4.R.inc(173);handleStart(startDirectory, results);</span>
<span class="fc" id="L340">            __CLR4_4_14646kylvdyb4.R.inc(174);walk(startDirectory, 0, results);</span>
<span class="fc" id="L341">            __CLR4_4_14646kylvdyb4.R.inc(175);handleEnd(results);</span>
<span class="fc" id="L342">        } catch(final CancelException cancel) {</span>
<span class="fc" id="L343">            __CLR4_4_14646kylvdyb4.R.inc(176);handleCancelled(startDirectory, results, cancel);</span>
<span class="fc" id="L344">        }</span>
<span class="fc" id="L345">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Main recursive method to examine the directory hierarchy.
     *
     * @param directory  the directory to examine, not null
     * @param depth  the directory level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
<span class="fc" id="L355">    private void walk(final File directory, final int depth, final Collection&lt;T&gt; results) throws IOException {try{__CLR4_4_14646kylvdyb4.R.inc(177);</span>
<span class="fc" id="L356">        __CLR4_4_14646kylvdyb4.R.inc(178);checkIfCancelled(directory, depth, results);</span>
<span class="pc bpc" id="L357" title="4 of 10 branches missed.">        __CLR4_4_14646kylvdyb4.R.inc(179);if ((((handleDirectory(directory, depth, results))&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(180)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(181)==0&amp;false))) {{</span>
<span class="fc" id="L358">            __CLR4_4_14646kylvdyb4.R.inc(182);handleDirectoryStart(directory, depth, results);</span>
<span class="fc" id="L359">            __CLR4_4_14646kylvdyb4.R.inc(183);final int childDepth = depth + 1;</span>
<span class="pc bpc" id="L360" title="4 of 12 branches missed.">            __CLR4_4_14646kylvdyb4.R.inc(184);if ((((depthLimit &lt; 0 || childDepth &lt;= depthLimit)&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(185)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(186)==0&amp;false))) {{</span>
<span class="fc" id="L361">                __CLR4_4_14646kylvdyb4.R.inc(187);checkIfCancelled(directory, depth, results);</span>
<span class="pc bpc" id="L362" title="4 of 10 branches missed.">                __CLR4_4_14646kylvdyb4.R.inc(188);File[] childFiles = (((filter == null )&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(189)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(190)==0&amp;false))? directory.listFiles() : directory.listFiles(filter);</span>
<span class="fc" id="L363">                __CLR4_4_14646kylvdyb4.R.inc(191);childFiles = filterDirectoryContents(directory, depth, childFiles);</span>
<span class="pc bpc" id="L364" title="4 of 10 branches missed.">                __CLR4_4_14646kylvdyb4.R.inc(192);if ((((childFiles == null)&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(193)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(194)==0&amp;false))) {{</span>
<span class="fc" id="L365">                    __CLR4_4_14646kylvdyb4.R.inc(195);handleRestricted(directory, childDepth, results);</span>
                } }else {{
<span class="fc bfc" id="L367" title="All 2 branches covered.">                    __CLR4_4_14646kylvdyb4.R.inc(196);for (final File childFile : childFiles) {{</span>
<span class="pc bpc" id="L368" title="4 of 10 branches missed.">                        __CLR4_4_14646kylvdyb4.R.inc(197);if ((((childFile.isDirectory())&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(198)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(199)==0&amp;false))) {{</span>
<span class="fc" id="L369">                            __CLR4_4_14646kylvdyb4.R.inc(200);walk(childFile, childDepth, results);</span>
                        } }else {{
<span class="fc" id="L371">                            __CLR4_4_14646kylvdyb4.R.inc(201);checkIfCancelled(childFile, childDepth, results);</span>
<span class="fc" id="L372">                            __CLR4_4_14646kylvdyb4.R.inc(202);handleFile(childFile, childDepth, results);</span>
<span class="fc" id="L373">                            __CLR4_4_14646kylvdyb4.R.inc(203);checkIfCancelled(childFile, childDepth, results);</span>
                        }
                    }}
                }}
            }}
<span class="fc" id="L378">            }__CLR4_4_14646kylvdyb4.R.inc(204);handleDirectoryEnd(directory, depth, results);</span>
        }
<span class="fc" id="L380">        }__CLR4_4_14646kylvdyb4.R.inc(205);checkIfCancelled(directory, depth, results);</span>
<span class="fc" id="L381">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Checks whether the walk has been cancelled by calling {@link #handleIsCancelled},
     * throwing a {@code CancelException} if it has.
     * &lt;p&gt;
     * Writers of subclasses should not normally call this method as it is called
     * automatically by the walk of the tree. However, sometimes a single method,
     * typically {@link #handleFile}, may take a long time to run. In that case,
     * you may wish to check for cancellation by calling this method.
     * &lt;/p&gt;
     *
     * @param file  the current file being processed
     * @param depth  the current file level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
    protected final void checkIfCancelled(final File file, final int depth, final Collection&lt;T&gt; results) throws
<span class="fc" id="L399">            IOException {try{__CLR4_4_14646kylvdyb4.R.inc(206);</span>
<span class="pc bpc" id="L400" title="4 of 10 branches missed.">        __CLR4_4_14646kylvdyb4.R.inc(207);if ((((handleIsCancelled(file, depth, results))&amp;&amp;(__CLR4_4_14646kylvdyb4.R.iget(208)!=0|true))||(__CLR4_4_14646kylvdyb4.R.iget(209)==0&amp;false))) {{</span>
<span class="fc" id="L401">            __CLR4_4_14646kylvdyb4.R.inc(210);throw new CancelException(file, depth);</span>
        }
<span class="fc" id="L403">    }}finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked to determine if the entire walk
     * operation should be immediately cancelled.
     * &lt;p&gt;
     * This method should be implemented by those subclasses that want to
     * provide a public {@code cancel()} method available from another
     * thread. The design pattern for the subclass should be as follows:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  public class FooDirectoryWalker extends DirectoryWalker {
     *    private volatile boolean cancelled = false;
     *
     *    public void cancel() {
     *        cancelled = true;
     *    }
     *    private void handleIsCancelled(File file, int depth, Collection results) {
     *        return cancelled;
     *    }
     *    protected void handleCancelled(File startDirectory,
     *              Collection results, CancelException cancel) {
     *        // implement processing required when a cancellation occurs
     *    }
     *  }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * If this method returns true, then the directory walk is immediately
     * cancelled. The next callback method will be {@link #handleCancelled}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This implementation returns false.
     * &lt;/p&gt;
     *
     * @param file  the file or directory being processed
     * @param depth  the current directory level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @return true if the walk has been cancelled
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
    protected boolean handleIsCancelled(
<span class="fc" id="L445">            final File file, final int depth, final Collection&lt;T&gt; results) throws IOException {try{__CLR4_4_14646kylvdyb4.R.inc(211);</span>
        // do nothing - overridable by subclass
<span class="fc" id="L447">        __CLR4_4_14646kylvdyb4.R.inc(212);return false;  // not cancelled</span>
<span class="fc" id="L448">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked when the operation is cancelled.
     * The file being processed when the cancellation occurred can be
     * obtained from the exception.
     * &lt;p&gt;
     * This implementation just re-throws the {@link CancelException}.
     * &lt;/p&gt;
     *
     * @param startDirectory  the directory that the walk started from
     * @param results  the collection of result objects, may be updated
     * @param cancel  the exception throw to cancel further processing
     * containing details at the point of cancellation.
     * @throws IOException if an I/O Error occurs
     */
    protected void handleCancelled(final File startDirectory, final Collection&lt;T&gt; results,
<span class="fc" id="L465">                       final CancelException cancel) throws IOException {try{__CLR4_4_14646kylvdyb4.R.inc(213);</span>
        // re-throw exception - overridable by subclass
<span class="fc" id="L467">        __CLR4_4_14646kylvdyb4.R.inc(214);throw cancel;</span>
<span class="fc" id="L468">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked at the start of processing.
     * &lt;p&gt;
     * This implementation does nothing.
     * &lt;/p&gt;
     *
     * @param startDirectory  the directory to start from
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
<span class="fc" id="L481">    protected void handleStart(final File startDirectory, final Collection&lt;T&gt; results) throws IOException {try{__CLR4_4_14646kylvdyb4.R.inc(215);</span>
        // do nothing - overridable by subclass
<span class="fc" id="L483">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked to determine if a directory should be processed.
     * &lt;p&gt;
     * This method returns a boolean to indicate if the directory should be examined or not.
     * If you return false, the entire directory and any subdirectories will be skipped.
     * Note that this functionality is in addition to the filtering by file filter.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This implementation does nothing and returns true.
     * &lt;/p&gt;
     *
     * @param directory  the current directory being processed
     * @param depth  the current directory level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @return true to process this directory, false to skip this directory
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
    protected boolean handleDirectory(final File directory, final int depth, final Collection&lt;T&gt; results) throws
<span class="fc" id="L504">            IOException {try{__CLR4_4_14646kylvdyb4.R.inc(216);</span>
        // do nothing - overridable by subclass
<span class="fc" id="L506">        __CLR4_4_14646kylvdyb4.R.inc(217);return true;  // process directory</span>
<span class="fc" id="L507">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked at the start of processing each directory.
     * &lt;p&gt;
     * This implementation does nothing.
     * &lt;/p&gt;
     *
     * @param directory  the current directory being processed
     * @param depth  the current directory level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
    protected void handleDirectoryStart(final File directory, final int depth, final Collection&lt;T&gt; results) throws
<span class="fc" id="L522">            IOException {try{__CLR4_4_14646kylvdyb4.R.inc(218);</span>
        // do nothing - overridable by subclass
<span class="fc" id="L524">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked with the contents of each directory.
     * &lt;p&gt;
     * This implementation returns the files unchanged
     * &lt;/p&gt;
     *
     * @param directory  the current directory being processed
     * @param depth  the current directory level (starting directory = 0)
     * @param files the files (possibly filtered) in the directory, may be {@code null}
     * @return the filtered list of files
     * @throws IOException if an I/O Error occurs
     * @since 2.0
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
    protected File[] filterDirectoryContents(final File directory, final int depth, final File... files) throws
<span class="fc" id="L541">            IOException {try{__CLR4_4_14646kylvdyb4.R.inc(219);</span>
<span class="fc" id="L542">        __CLR4_4_14646kylvdyb4.R.inc(220);return files;</span>
<span class="fc" id="L543">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked for each (non-directory) file.
     * &lt;p&gt;
     * This implementation does nothing.
     * &lt;/p&gt;
     *
     * @param file  the current file being processed
     * @param depth  the current directory level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
<span class="nc" id="L557">    protected void handleFile(final File file, final int depth, final Collection&lt;T&gt; results) throws IOException {try{__CLR4_4_14646kylvdyb4.R.inc(221);</span>
        // do nothing - overridable by subclass
<span class="nc" id="L559">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked for each restricted directory.
     * &lt;p&gt;
     * This implementation does nothing.
     * &lt;/p&gt;
     *
     * @param directory  the restricted directory
     * @param depth  the current directory level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
    protected void handleRestricted(final File directory, final int depth, final Collection&lt;T&gt; results) throws
<span class="fc" id="L574">            IOException {try{__CLR4_4_14646kylvdyb4.R.inc(222);</span>
        // do nothing - overridable by subclass
<span class="fc" id="L576">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked at the end of processing each directory.
     * &lt;p&gt;
     * This implementation does nothing.
     * &lt;/p&gt;
     *
     * @param directory  the directory being processed
     * @param depth  the current directory level (starting directory = 0)
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
    protected void handleDirectoryEnd(final File directory, final int depth, final Collection&lt;T&gt; results) throws
<span class="fc" id="L591">            IOException {try{__CLR4_4_14646kylvdyb4.R.inc(223);</span>
        // do nothing - overridable by subclass
<span class="fc" id="L593">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * Overridable callback method invoked at the end of processing.
     * &lt;p&gt;
     * This implementation does nothing.
     * &lt;/p&gt;
     *
     * @param results  the collection of result objects, may be updated
     * @throws IOException if an I/O Error occurs
     */
    @SuppressWarnings(&quot;unused&quot;) // Possibly thrown from subclasses.
<span class="fc" id="L605">    protected void handleEnd(final Collection&lt;T&gt; results) throws IOException {try{__CLR4_4_14646kylvdyb4.R.inc(224);</span>
        // do nothing - overridable by subclass
<span class="fc" id="L607">    }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

    /**
     * CancelException is thrown in DirectoryWalker to cancel the current
     * processing.
     */
    public static class CancelException extends IOException {

        /** Serialization id. */
        private static final long serialVersionUID = 1347339620135041008L;

        /** The file being processed when the exception was thrown. */
        private final File file;
        /** The file depth when the exception was thrown. */
        private final int depth;

        /**
         * Constructs a {@code CancelException} with
         * the file and depth when cancellation occurred.
         *
         * @param file  the file when the operation was cancelled, may be null
         * @param depth  the depth when the operation was cancelled, may be null
         */
        public CancelException(final File file, final int depth) {
<span class="fc" id="L631">            this(&quot;Operation Cancelled&quot;, file, depth);__CLR4_4_14646kylvdyb4.R.inc(226);try{__CLR4_4_14646kylvdyb4.R.inc(225);</span>
<span class="fc" id="L632">        }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

        /**
         * Constructs a {@code CancelException} with
         * an appropriate message and the file and depth when
         * cancellation occurred.
         *
         * @param message  the detail message
         * @param file  the file when the operation was cancelled
         * @param depth  the depth when the operation was cancelled
         */
        public CancelException(final String message, final File file, final int depth) {
<span class="fc" id="L644">            super(message);__CLR4_4_14646kylvdyb4.R.inc(228);try{__CLR4_4_14646kylvdyb4.R.inc(227);</span>
<span class="fc" id="L645">            __CLR4_4_14646kylvdyb4.R.inc(229);this.file = file;</span>
<span class="fc" id="L646">            __CLR4_4_14646kylvdyb4.R.inc(230);this.depth = depth;</span>
<span class="fc" id="L647">        }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

        /**
         * Returns the file when the operation was cancelled.
         *
         * @return the file when the operation was cancelled
         */
<span class="fc" id="L654">        public File getFile() {try{__CLR4_4_14646kylvdyb4.R.inc(231);</span>
<span class="fc" id="L655">            __CLR4_4_14646kylvdyb4.R.inc(232);return file;</span>
<span class="fc" id="L656">        }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>

        /**
         * Returns the depth when the operation was cancelled.
         *
         * @return the depth when the operation was cancelled
         */
<span class="fc" id="L663">        public int getDepth() {try{__CLR4_4_14646kylvdyb4.R.inc(233);</span>
<span class="fc" id="L664">            __CLR4_4_14646kylvdyb4.R.inc(234);return depth;</span>
<span class="fc" id="L665">        }finally{__CLR4_4_14646kylvdyb4.R.flushNeeded();}}</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>
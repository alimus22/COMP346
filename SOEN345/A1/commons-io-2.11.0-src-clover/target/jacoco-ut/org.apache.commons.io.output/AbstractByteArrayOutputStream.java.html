<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractByteArrayOutputStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons IO</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.io.output</a> &gt; <span class="el_source">AbstractByteArrayOutputStream.java</span></div><h1>AbstractByteArrayOutputStream.java</h1><pre class="source lang-java linenums">/* $$ This file has been instrumented by Clover 4.4.1#2019101123313948 $$ *//*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.io.output;

import org.apache.commons.io.IOUtils;
import org.apache.commons.io.input.ClosedInputStream;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.SequenceInputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.apache.commons.io.IOUtils.EOF;

/**
 * This is the base class for implementing an output stream in which the data
 * is written into a byte array. The buffer automatically grows as data
 * is written to it.
 * &lt;p&gt;
 * The data can be retrieved using {@code toByteArray()} and
 * {@code toString()}.
 * Closing an {@code AbstractByteArrayOutputStream} has no effect. The methods in
 * this class can be called after the stream has been closed without
 * generating an {@code IOException}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This is the base for an alternative implementation of the
 * {@link java.io.ByteArrayOutputStream} class. The original implementation
 * only allocates 32 bytes at the beginning. As this class is designed for
 * heavy duty it starts at {@value #DEFAULT_SIZE} bytes. In contrast to the original it doesn't
 * reallocate the whole memory block but allocates additional buffers. This
 * way no buffers need to be garbage collected and the contents don't have
 * to be copied to the new buffer. This class is designed to behave exactly
 * like the original. The only exception is the deprecated
 * {@link java.io.ByteArrayOutputStream#toString(int)} method that has been
 * ignored.
 * &lt;/p&gt;
 *
 * @since 2.7
 */
<span class="pc bpc" id="L60" title="3 of 4 branches missed.">public abstract class AbstractByteArrayOutputStream extends OutputStream {public static class __CLR4_4_16ke6kekylve09o{public static com_atlassian_clover.CoverageRecorder R;public static com_atlassian_clover.CloverProfile[] profiles = { };@java.lang.SuppressWarnings(&quot;unchecked&quot;) public static &lt;I, T extends I&gt; I lambdaInc(final int i,final T l,final int si){java.lang.reflect.InvocationHandler h=new java.lang.reflect.InvocationHandler(){public java.lang.Object invoke(java.lang.Object p,java.lang.reflect.Method m,java.lang.Object[] a) throws Throwable{R.inc(i);R.inc(si);try{return m.invoke(l,a);}catch(java.lang.reflect.InvocationTargetException e){throw e.getCause()!=null?e.getCause():new RuntimeException(&quot;Clover failed to invoke instrumented lambda&quot;,e);}}};return (I)java.lang.reflect.Proxy.newProxyInstance(l.getClass().getClassLoader(),l.getClass().getInterfaces(),h);}static{com_atlassian_clover.CoverageRecorder _R=null;try{com_atlassian_clover.CloverVersionInfo.An_old_version_of_clover_is_on_your_compilation_classpath___Please_remove___Required_version_is___4_4_1();if(2019101123313948L!=com_atlassian_clover.CloverVersionInfo.getBuildStamp()){com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: The Clover version used in instrumentation does not match the runtime version. You need to run instrumented classes against the same version of Clover that you instrumented with.&quot;);com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: Instr=4.4.1#2019101123313948,Runtime=&quot;+com_atlassian_clover.CloverVersionInfo.getReleaseNum()+&quot;#&quot;+com_atlassian_clover.CloverVersionInfo.getBuildStamp());}R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getRecorder(&quot;\u002f\u0055\u0073\u0065\u0072\u0073\u002f\u0061\u006c\u0069\u0068\u0061\u006e\u006e\u0069\u002f\u0044\u0065\u0073\u006b\u0074\u006f\u0070\u002f\u0047\u0069\u0074\u0048\u0075\u0062\u002f\u0053\u004f\u0045\u004e\u002f\u0053\u004f\u0045\u004e\u0033\u0034\u0035\u002f\u0041\u0031\u002f\u0063\u006f\u006d\u006d\u006f\u006e\u0073\u002d\u0069\u006f\u002d\u0032\u002e\u0031\u0031\u002e\u0030\u002d\u0073\u0072\u0063\u002f\u0074\u0061\u0072\u0067\u0065\u0074\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002e\u0064\u0062&quot;,1642616389890L,8589935092L,8635,profiles,new java.lang.String[]{&quot;clover.distributed.coverage&quot;,null});}catch(java.lang.SecurityException e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because it has insufficient security privileges. Please consult the Clover documentation on the security policy file changes required. (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.NoClassDefFoundError e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.Throwable t){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because of an unexpected error. (&quot;+t.getClass()+&quot;:&quot;+t.getMessage()+&quot;)&quot;);}R=_R;}}public static final com_atlassian_clover.TestNameSniffer __CLR4_4_1_TEST_NAME_SNIFFER=com_atlassian_clover.TestNameSniffer.NULL_INSTANCE;</span>

    static final int DEFAULT_SIZE = 1024;

    /** The list of buffers, which grows and never reduces. */
<span class="fc" id="L65">    private final List&lt;byte[]&gt; buffers = new ArrayList&lt;&gt;();</span>
    /** The index of the current buffer. */
    private int currentBufferIndex;
    /** The total count of bytes in all the filled buffers. */
    private int filledBufferSum;
    /** The current buffer. */
    private byte[] currentBuffer;
    /** The total count of bytes written. */
    protected int count;
    /** Flag to indicate if the buffers can be reused after reset */
<span class="fc" id="L75">    private boolean reuseBuffers = true;</span>

    /**
     * Makes a new buffer available either by allocating
     * a new one or re-cycling an existing one.
     *
     * @param newcount  the size of the buffer if one is created
     */
<span class="fc" id="L83">    protected void needNewBuffer(final int newcount) {try{__CLR4_4_16ke6kekylve09o.R.inc(8510);</span>
<span class="pc bpc" id="L84" title="4 of 10 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8511);if ((((currentBufferIndex &lt; buffers.size() - 1)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8512)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8513)==0&amp;false))) {{</span>
            //Recycling old buffer
<span class="fc" id="L86">            __CLR4_4_16ke6kekylve09o.R.inc(8514);filledBufferSum += currentBuffer.length;</span>

<span class="fc" id="L88">            __CLR4_4_16ke6kekylve09o.R.inc(8515);currentBufferIndex++;</span>
<span class="fc" id="L89">            __CLR4_4_16ke6kekylve09o.R.inc(8516);currentBuffer = buffers.get(currentBufferIndex);</span>
        } }else {{
            //Creating new buffer
<span class="fc" id="L92">            __CLR4_4_16ke6kekylve09o.R.inc(8517);final int newBufferSize;</span>
<span class="pc bpc" id="L93" title="4 of 10 branches missed.">            __CLR4_4_16ke6kekylve09o.R.inc(8518);if ((((currentBuffer == null)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8519)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8520)==0&amp;false))) {{</span>
<span class="fc" id="L94">                __CLR4_4_16ke6kekylve09o.R.inc(8521);newBufferSize = newcount;</span>
<span class="fc" id="L95">                __CLR4_4_16ke6kekylve09o.R.inc(8522);filledBufferSum = 0;</span>
            } }else {{
<span class="fc" id="L97">                __CLR4_4_16ke6kekylve09o.R.inc(8523);newBufferSize = Math.max(</span>
                    currentBuffer.length &lt;&lt; 1,
                    newcount - filledBufferSum);
<span class="fc" id="L100">                __CLR4_4_16ke6kekylve09o.R.inc(8524);filledBufferSum += currentBuffer.length;</span>
            }

<span class="fc" id="L103">            }__CLR4_4_16ke6kekylve09o.R.inc(8525);currentBufferIndex++;</span>
<span class="fc" id="L104">            __CLR4_4_16ke6kekylve09o.R.inc(8526);currentBuffer = IOUtils.byteArray(newBufferSize);</span>
<span class="fc" id="L105">            __CLR4_4_16ke6kekylve09o.R.inc(8527);buffers.add(currentBuffer);</span>
        }
<span class="fc" id="L107">    }}finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Writes the bytes to the byte array.
     * @param b the bytes to write
     * @param off The start offset
     * @param len The number of bytes to write
     */
    @Override
    public abstract void write(final byte[] b, final int off, final int len);

    /**
     * Writes the bytes to the byte array.
     * @param b the bytes to write
     * @param off The start offset
     * @param len The number of bytes to write
     */
<span class="fc" id="L124">    protected void writeImpl(final byte[] b, final int off, final int len) {try{__CLR4_4_16ke6kekylve09o.R.inc(8528);</span>
<span class="fc" id="L125">        __CLR4_4_16ke6kekylve09o.R.inc(8529);final int newcount = count + len;</span>
<span class="fc" id="L126">        __CLR4_4_16ke6kekylve09o.R.inc(8530);int remaining = len;</span>
<span class="fc" id="L127">        __CLR4_4_16ke6kekylve09o.R.inc(8531);int inBufferPos = count - filledBufferSum;</span>
<span class="pc bpc" id="L128" title="4 of 10 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8532);while ((((remaining &gt; 0)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8533)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8534)==0&amp;false))) {{</span>
<span class="fc" id="L129">            __CLR4_4_16ke6kekylve09o.R.inc(8535);final int part = Math.min(remaining, currentBuffer.length - inBufferPos);</span>
<span class="fc" id="L130">            __CLR4_4_16ke6kekylve09o.R.inc(8536);System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);</span>
<span class="fc" id="L131">            __CLR4_4_16ke6kekylve09o.R.inc(8537);remaining -= part;</span>
<span class="pc bpc" id="L132" title="4 of 10 branches missed.">            __CLR4_4_16ke6kekylve09o.R.inc(8538);if ((((remaining &gt; 0)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8539)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8540)==0&amp;false))) {{</span>
<span class="fc" id="L133">                __CLR4_4_16ke6kekylve09o.R.inc(8541);needNewBuffer(newcount);</span>
<span class="fc" id="L134">                __CLR4_4_16ke6kekylve09o.R.inc(8542);inBufferPos = 0;</span>
            }
<span class="fc" id="L136">        }}</span>
<span class="fc" id="L137">        }__CLR4_4_16ke6kekylve09o.R.inc(8543);count = newcount;</span>
<span class="fc" id="L138">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Write a byte to byte array.
     * @param b the byte to write
     */
    @Override
    public abstract void write(final int b);

    /**
     * Write a byte to byte array.
     * @param b the byte to write
     */
<span class="fc" id="L151">    protected void writeImpl(final int b) {try{__CLR4_4_16ke6kekylve09o.R.inc(8544);</span>
<span class="fc" id="L152">        __CLR4_4_16ke6kekylve09o.R.inc(8545);int inBufferPos = count - filledBufferSum;</span>
<span class="pc bpc" id="L153" title="4 of 10 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8546);if ((((inBufferPos == currentBuffer.length)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8547)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8548)==0&amp;false))) {{</span>
<span class="fc" id="L154">            __CLR4_4_16ke6kekylve09o.R.inc(8549);needNewBuffer(count + 1);</span>
<span class="fc" id="L155">            __CLR4_4_16ke6kekylve09o.R.inc(8550);inBufferPos = 0;</span>
        }
<span class="fc" id="L157">        }__CLR4_4_16ke6kekylve09o.R.inc(8551);currentBuffer[inBufferPos] = (byte) b;</span>
<span class="fc" id="L158">        __CLR4_4_16ke6kekylve09o.R.inc(8552);count++;</span>
<span class="fc" id="L159">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>


    /**
     * Writes the entire contents of the specified input stream to this
     * byte stream. Bytes from the input stream are read directly into the
     * internal buffers of this streams.
     *
     * @param in the input stream to read from
     * @return total number of bytes read from the input stream
     *         (and written to this stream)
     * @throws IOException if an I/O error occurs while reading the input stream
     * @since 1.4
     */
    public abstract int write(final InputStream in) throws IOException;

    /**
     * Writes the entire contents of the specified input stream to this
     * byte stream. Bytes from the input stream are read directly into the
     * internal buffers of this streams.
     *
     * @param in the input stream to read from
     * @return total number of bytes read from the input stream
     *         (and written to this stream)
     * @throws IOException if an I/O error occurs while reading the input stream
     * @since 2.7
     */
<span class="fc" id="L186">    protected int writeImpl(final InputStream in) throws IOException {try{__CLR4_4_16ke6kekylve09o.R.inc(8553);</span>
<span class="fc" id="L187">        __CLR4_4_16ke6kekylve09o.R.inc(8554);int readCount = 0;</span>
<span class="fc" id="L188">        __CLR4_4_16ke6kekylve09o.R.inc(8555);int inBufferPos = count - filledBufferSum;</span>
<span class="fc" id="L189">        __CLR4_4_16ke6kekylve09o.R.inc(8556);int n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);</span>
<span class="pc bpc" id="L190" title="4 of 10 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8557);while ((((n != EOF)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8558)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8559)==0&amp;false))) {{</span>
<span class="fc" id="L191">            __CLR4_4_16ke6kekylve09o.R.inc(8560);readCount += n;</span>
<span class="fc" id="L192">            __CLR4_4_16ke6kekylve09o.R.inc(8561);inBufferPos += n;</span>
<span class="fc" id="L193">            __CLR4_4_16ke6kekylve09o.R.inc(8562);count += n;</span>
<span class="pc bpc" id="L194" title="4 of 10 branches missed.">            __CLR4_4_16ke6kekylve09o.R.inc(8563);if ((((inBufferPos == currentBuffer.length)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8564)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8565)==0&amp;false))) {{</span>
<span class="fc" id="L195">                __CLR4_4_16ke6kekylve09o.R.inc(8566);needNewBuffer(currentBuffer.length);</span>
<span class="fc" id="L196">                __CLR4_4_16ke6kekylve09o.R.inc(8567);inBufferPos = 0;</span>
            }
<span class="fc" id="L198">            }__CLR4_4_16ke6kekylve09o.R.inc(8568);n = in.read(currentBuffer, inBufferPos, currentBuffer.length - inBufferPos);</span>
        }
<span class="fc" id="L200">        }__CLR4_4_16ke6kekylve09o.R.inc(8569);return readCount;</span>
<span class="fc" id="L201">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Returns the current size of the byte array.
     *
     * @return the current size of the byte array
     */
    public abstract int size();

    /**
     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in
     * this class can be called after the stream has been closed without
     * generating an {@code IOException}.
     *
     * @throws IOException never (this method should not declare this exception
     * but it has to now due to backwards compatibility)
     */
    @Override
<span class="fc" id="L219">    public void close() throws IOException {try{__CLR4_4_16ke6kekylve09o.R.inc(8570);</span>
        //nop
<span class="fc" id="L221">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * @see java.io.ByteArrayOutputStream#reset()
     */
    public abstract void reset();

    /**
     * @see java.io.ByteArrayOutputStream#reset()
     */
<span class="fc" id="L231">    protected void resetImpl() {try{__CLR4_4_16ke6kekylve09o.R.inc(8571);</span>
<span class="fc" id="L232">        __CLR4_4_16ke6kekylve09o.R.inc(8572);count = 0;</span>
<span class="fc" id="L233">        __CLR4_4_16ke6kekylve09o.R.inc(8573);filledBufferSum = 0;</span>
<span class="fc" id="L234">        __CLR4_4_16ke6kekylve09o.R.inc(8574);currentBufferIndex = 0;</span>
<span class="pc bpc" id="L235" title="4 of 10 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8575);if ((((reuseBuffers)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8576)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8577)==0&amp;false))) {{</span>
<span class="fc" id="L236">            __CLR4_4_16ke6kekylve09o.R.inc(8578);currentBuffer = buffers.get(currentBufferIndex);</span>
        } }else {{
            //Throw away old buffers
<span class="fc" id="L239">            __CLR4_4_16ke6kekylve09o.R.inc(8579);currentBuffer = null;</span>
<span class="fc" id="L240">            __CLR4_4_16ke6kekylve09o.R.inc(8580);final int size = buffers.get(0).length;</span>
<span class="fc" id="L241">            __CLR4_4_16ke6kekylve09o.R.inc(8581);buffers.clear();</span>
<span class="fc" id="L242">            __CLR4_4_16ke6kekylve09o.R.inc(8582);needNewBuffer(size);</span>
<span class="fc" id="L243">            __CLR4_4_16ke6kekylve09o.R.inc(8583);reuseBuffers = true;</span>
        }
<span class="fc" id="L245">    }}finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Writes the entire contents of this byte stream to the
     * specified output stream.
     *
     * @param out  the output stream to write to
     * @throws IOException if an I/O error occurs, such as if the stream is closed
     * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)
     */
    public abstract void writeTo(final OutputStream out) throws IOException;

    /**
     * Writes the entire contents of this byte stream to the
     * specified output stream.
     *
     * @param out  the output stream to write to
     * @throws IOException if an I/O error occurs, such as if the stream is closed
     * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)
     */
<span class="fc" id="L265">    protected void writeToImpl(final OutputStream out) throws IOException {try{__CLR4_4_16ke6kekylve09o.R.inc(8584);</span>
<span class="fc" id="L266">        __CLR4_4_16ke6kekylve09o.R.inc(8585);int remaining = count;</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8586);for (final byte[] buf : buffers) {{</span>
<span class="fc" id="L268">            __CLR4_4_16ke6kekylve09o.R.inc(8587);final int c = Math.min(buf.length, remaining);</span>
<span class="fc" id="L269">            __CLR4_4_16ke6kekylve09o.R.inc(8588);out.write(buf, 0, c);</span>
<span class="fc" id="L270">            __CLR4_4_16ke6kekylve09o.R.inc(8589);remaining -= c;</span>
<span class="pc bpc" id="L271" title="4 of 10 branches missed.">            __CLR4_4_16ke6kekylve09o.R.inc(8590);if ((((remaining == 0)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8591)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8592)==0&amp;false))) {{</span>
<span class="fc" id="L272">                __CLR4_4_16ke6kekylve09o.R.inc(8593);break;</span>
            }
        }}
<span class="fc" id="L275">    }}finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Gets the current contents of this byte stream as a Input Stream. The
     * returned stream is backed by buffers of {@code this} stream,
     * avoiding memory allocation and copy, thus saving space and time.&lt;br&gt;
     *
     * @return the current contents of this output stream.
     * @see java.io.ByteArrayOutputStream#toByteArray()
     * @see #reset()
     * @since 2.5
     */
    public abstract InputStream toInputStream();

    /**
     * Gets the current contents of this byte stream as a Input Stream. The
     * returned stream is backed by buffers of {@code this} stream,
     * avoiding memory allocation and copy, thus saving space and time.&lt;br&gt;
     *
     * @param &lt;T&gt; the type of the InputStream which makes up
     *            the {@link SequenceInputStream}.
     * @param isConstructor A constructor for an InputStream which makes
     *                     up the {@link SequenceInputStream}.
     *
     * @return the current contents of this output stream.
     * @see java.io.ByteArrayOutputStream#toByteArray()
     * @see #reset()
     * @since 2.7
     */
    @SuppressWarnings(&quot;resource&quot;) // The result InputStream MUST be managed by the call site.
    protected &lt;T extends InputStream&gt; InputStream toInputStream(
<span class="fc" id="L306">            final InputStreamConstructor&lt;T&gt; isConstructor) {try{__CLR4_4_16ke6kekylve09o.R.inc(8594);</span>
<span class="fc" id="L307">        __CLR4_4_16ke6kekylve09o.R.inc(8595);int remaining = count;</span>
<span class="pc bpc" id="L308" title="4 of 10 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8596);if ((((remaining == 0)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8597)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8598)==0&amp;false))) {{</span>
<span class="fc" id="L309">            __CLR4_4_16ke6kekylve09o.R.inc(8599);return ClosedInputStream.CLOSED_INPUT_STREAM;</span>
        }
<span class="fc" id="L311">        }__CLR4_4_16ke6kekylve09o.R.inc(8600);final List&lt;T&gt; list = new ArrayList&lt;&gt;(buffers.size());</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8601);for (final byte[] buf : buffers) {{</span>
<span class="fc" id="L313">            __CLR4_4_16ke6kekylve09o.R.inc(8602);final int c = Math.min(buf.length, remaining);</span>
<span class="fc" id="L314">            __CLR4_4_16ke6kekylve09o.R.inc(8603);list.add(isConstructor.construct(buf, 0, c));</span>
<span class="fc" id="L315">            __CLR4_4_16ke6kekylve09o.R.inc(8604);remaining -= c;</span>
<span class="pc bpc" id="L316" title="4 of 10 branches missed.">            __CLR4_4_16ke6kekylve09o.R.inc(8605);if ((((remaining == 0)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8606)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8607)==0&amp;false))) {{</span>
<span class="fc" id="L317">                __CLR4_4_16ke6kekylve09o.R.inc(8608);break;</span>
            }
        }}
<span class="fc" id="L320">        }__CLR4_4_16ke6kekylve09o.R.inc(8609);reuseBuffers = false;</span>
<span class="fc" id="L321">        __CLR4_4_16ke6kekylve09o.R.inc(8610);return new SequenceInputStream(Collections.enumeration(list));</span>
<span class="fc" id="L322">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Constructor for an InputStream subclass.
     *
     * @param &lt;T&gt; the type of the InputStream.
     */
    @FunctionalInterface
    protected interface InputStreamConstructor&lt;T extends InputStream&gt; {

        /**
         * Construct an InputStream subclass.
         *
         * @param buf the buffer
         * @param offset the offset into the buffer
         * @param length the length of the buffer
         *
         * @return the InputStream subclass.
         */
        T construct(final byte[] buf, final int offset, final int length);
    }

    /**
     * Gets the current contents of this byte stream as a byte array.
     * The result is independent of this stream.
     *
     * @return the current contents of this output stream, as a byte array
     * @see java.io.ByteArrayOutputStream#toByteArray()
     */
    public abstract byte[] toByteArray();

    /**
     * Gets the current contents of this byte stream as a byte array.
     * The result is independent of this stream.
     *
     * @return the current contents of this output stream, as a byte array
     * @see java.io.ByteArrayOutputStream#toByteArray()
     */
<span class="fc" id="L360">    protected byte[] toByteArrayImpl() {try{__CLR4_4_16ke6kekylve09o.R.inc(8611);</span>
<span class="fc" id="L361">        __CLR4_4_16ke6kekylve09o.R.inc(8612);int remaining = count;</span>
<span class="pc bpc" id="L362" title="4 of 10 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8613);if ((((remaining == 0)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8614)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8615)==0&amp;false))) {{</span>
<span class="fc" id="L363">            __CLR4_4_16ke6kekylve09o.R.inc(8616);return IOUtils.EMPTY_BYTE_ARRAY;</span>
        }
<span class="fc" id="L365">        }__CLR4_4_16ke6kekylve09o.R.inc(8617);final byte[] newbuf = IOUtils.byteArray(remaining);</span>
<span class="fc" id="L366">        __CLR4_4_16ke6kekylve09o.R.inc(8618);int pos = 0;</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        __CLR4_4_16ke6kekylve09o.R.inc(8619);for (final byte[] buf : buffers) {{</span>
<span class="fc" id="L368">            __CLR4_4_16ke6kekylve09o.R.inc(8620);final int c = Math.min(buf.length, remaining);</span>
<span class="fc" id="L369">            __CLR4_4_16ke6kekylve09o.R.inc(8621);System.arraycopy(buf, 0, newbuf, pos, c);</span>
<span class="fc" id="L370">            __CLR4_4_16ke6kekylve09o.R.inc(8622);pos += c;</span>
<span class="fc" id="L371">            __CLR4_4_16ke6kekylve09o.R.inc(8623);remaining -= c;</span>
<span class="pc bpc" id="L372" title="4 of 10 branches missed.">            __CLR4_4_16ke6kekylve09o.R.inc(8624);if ((((remaining == 0)&amp;&amp;(__CLR4_4_16ke6kekylve09o.R.iget(8625)!=0|true))||(__CLR4_4_16ke6kekylve09o.R.iget(8626)==0&amp;false))) {{</span>
<span class="fc" id="L373">                __CLR4_4_16ke6kekylve09o.R.inc(8627);break;</span>
            }
        }}
<span class="fc" id="L376">        }__CLR4_4_16ke6kekylve09o.R.inc(8628);return newbuf;</span>
<span class="fc" id="L377">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Gets the current contents of this byte stream as a string
     * using the platform default charset.
     * @return the contents of the byte array as a String
     * @see java.io.ByteArrayOutputStream#toString()
     * @deprecated 2.5 use {@link #toString(String)} instead
     */
    @Override
    @Deprecated
<span class="fc" id="L388">    public String toString() {try{__CLR4_4_16ke6kekylve09o.R.inc(8629);</span>
        // make explicit the use of the default charset
<span class="fc" id="L390">        __CLR4_4_16ke6kekylve09o.R.inc(8630);return new String(toByteArray(), Charset.defaultCharset());</span>
<span class="fc" id="L391">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Gets the current contents of this byte stream as a string
     * using the specified encoding.
     *
     * @param enc  the name of the character encoding
     * @return the string converted from the byte array
     * @throws UnsupportedEncodingException if the encoding is not supported
     * @see java.io.ByteArrayOutputStream#toString(String)
     */
<span class="fc" id="L402">    public String toString(final String enc) throws UnsupportedEncodingException {try{__CLR4_4_16ke6kekylve09o.R.inc(8631);</span>
<span class="fc" id="L403">        __CLR4_4_16ke6kekylve09o.R.inc(8632);return new String(toByteArray(), enc);</span>
<span class="fc" id="L404">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

    /**
     * Gets the current contents of this byte stream as a string
     * using the specified encoding.
     *
     * @param charset  the character encoding
     * @return the string converted from the byte array
     * @see java.io.ByteArrayOutputStream#toString(String)
     * @since 2.5
     */
<span class="fc" id="L415">    public String toString(final Charset charset) {try{__CLR4_4_16ke6kekylve09o.R.inc(8633);</span>
<span class="fc" id="L416">        __CLR4_4_16ke6kekylve09o.R.inc(8634);return new String(toByteArray(), charset);</span>
<span class="fc" id="L417">    }finally{__CLR4_4_16ke6kekylve09o.R.flushNeeded();}}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>
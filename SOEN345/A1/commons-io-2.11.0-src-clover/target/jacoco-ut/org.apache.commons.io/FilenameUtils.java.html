<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilenameUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons IO</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.io</a> &gt; <span class="el_source">FilenameUtils.java</span></div><h1>FilenameUtils.java</h1><pre class="source lang-java linenums">/* $$ This file has been instrumented by Clover 4.4.1#2019101123313948 $$ *//*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.io;

import java.io.File;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * General file name and file path manipulation utilities.
 * &lt;p&gt;
 * When dealing with file names you can hit problems when moving from a Windows
 * based development machine to a Unix based production machine.
 * This class aims to help avoid those problems.
 * &lt;p&gt;
 * &lt;b&gt;NOTE&lt;/b&gt;: You may be able to avoid using this class entirely simply by
 * using JDK {@link java.io.File File} objects and the two argument constructor
 * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.
 * &lt;p&gt;
 * Most methods on this class are designed to work the same on both Unix and Windows.
 * Those that don't include 'System', 'Unix' or 'Windows' in their name.
 * &lt;p&gt;
 * Most methods recognize both separators (forward and back), and both
 * sets of prefixes. See the Javadoc of each method for details.
 * &lt;p&gt;
 * This class defines six components within a file name
 * (example C:\dev\project\file.txt):
 * &lt;ul&gt;
 * &lt;li&gt;the prefix - C:\&lt;/li&gt;
 * &lt;li&gt;the path - dev\project\&lt;/li&gt;
 * &lt;li&gt;the full path - C:\dev\project\&lt;/li&gt;
 * &lt;li&gt;the name - file.txt&lt;/li&gt;
 * &lt;li&gt;the base name - file&lt;/li&gt;
 * &lt;li&gt;the extension - txt&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that this class works best if directory file names end with a separator.
 * If you omit the last separator, it is impossible to determine if the file name
 * corresponds to a file or a directory. As a result, we have chosen to say
 * it corresponds to a file.
 * &lt;p&gt;
 * This class only supports Unix and Windows style names.
 * Prefixes are matched as follows:
 * &lt;pre&gt;
 * Windows:
 * a\b\c.txt           --&amp;gt; &quot;&quot;          --&amp;gt; relative
 * \a\b\c.txt          --&amp;gt; &quot;\&quot;         --&amp;gt; current drive absolute
 * C:a\b\c.txt         --&amp;gt; &quot;C:&quot;        --&amp;gt; drive relative
 * C:\a\b\c.txt        --&amp;gt; &quot;C:\&quot;       --&amp;gt; absolute
 * \\server\a\b\c.txt  --&amp;gt; &quot;\\server\&quot; --&amp;gt; UNC
 *
 * Unix:
 * a/b/c.txt           --&amp;gt; &quot;&quot;          --&amp;gt; relative
 * /a/b/c.txt          --&amp;gt; &quot;/&quot;         --&amp;gt; absolute
 * ~/a/b/c.txt         --&amp;gt; &quot;~/&quot;        --&amp;gt; current user
 * ~                   --&amp;gt; &quot;~/&quot;        --&amp;gt; current user (slash added)
 * ~user/a/b/c.txt     --&amp;gt; &quot;~user/&quot;    --&amp;gt; named user
 * ~user               --&amp;gt; &quot;~user/&quot;    --&amp;gt; named user (slash added)
 * &lt;/pre&gt;
 * Both prefix styles are matched always, irrespective of the machine that you are
 * currently running on.
 * &lt;p&gt;
 * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.
 *
 * @since 1.1
 */
<span class="pc bpc" id="L87" title="3 of 4 branches missed.">public class FilenameUtils {public static class __CLR4_4_11a31a3kylvdytv{public static com_atlassian_clover.CoverageRecorder R;public static com_atlassian_clover.CloverProfile[] profiles = { };@java.lang.SuppressWarnings(&quot;unchecked&quot;) public static &lt;I, T extends I&gt; I lambdaInc(final int i,final T l,final int si){java.lang.reflect.InvocationHandler h=new java.lang.reflect.InvocationHandler(){public java.lang.Object invoke(java.lang.Object p,java.lang.reflect.Method m,java.lang.Object[] a) throws Throwable{R.inc(i);R.inc(si);try{return m.invoke(l,a);}catch(java.lang.reflect.InvocationTargetException e){throw e.getCause()!=null?e.getCause():new RuntimeException(&quot;Clover failed to invoke instrumented lambda&quot;,e);}}};return (I)java.lang.reflect.Proxy.newProxyInstance(l.getClass().getClassLoader(),l.getClass().getInterfaces(),h);}static{com_atlassian_clover.CoverageRecorder _R=null;try{com_atlassian_clover.CloverVersionInfo.An_old_version_of_clover_is_on_your_compilation_classpath___Please_remove___Required_version_is___4_4_1();if(2019101123313948L!=com_atlassian_clover.CloverVersionInfo.getBuildStamp()){com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: The Clover version used in instrumentation does not match the runtime version. You need to run instrumented classes against the same version of Clover that you instrumented with.&quot;);com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: Instr=4.4.1#2019101123313948,Runtime=&quot;+com_atlassian_clover.CloverVersionInfo.getReleaseNum()+&quot;#&quot;+com_atlassian_clover.CloverVersionInfo.getBuildStamp());}R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getRecorder(&quot;\u002f\u0055\u0073\u0065\u0072\u0073\u002f\u0061\u006c\u0069\u0068\u0061\u006e\u006e\u0069\u002f\u0044\u0065\u0073\u006b\u0074\u006f\u0070\u002f\u0047\u0069\u0074\u0048\u0075\u0062\u002f\u0053\u004f\u0045\u004e\u002f\u0053\u004f\u0045\u004e\u0033\u0034\u0035\u002f\u0041\u0031\u002f\u0063\u006f\u006d\u006d\u006f\u006e\u0073\u002d\u0069\u006f\u002d\u0032\u002e\u0031\u0031\u002e\u0030\u002d\u0073\u0072\u0063\u002f\u0074\u0061\u0072\u0067\u0065\u0074\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002e\u0064\u0062&quot;,1642616389890L,8589935092L,2370,profiles,new java.lang.String[]{&quot;clover.distributed.coverage&quot;,null});}catch(java.lang.SecurityException e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because it has insufficient security privileges. Please consult the Clover documentation on the security policy file changes required. (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.NoClassDefFoundError e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.Throwable t){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because of an unexpected error. (&quot;+t.getClass()+&quot;:&quot;+t.getMessage()+&quot;)&quot;);}R=_R;}}public static final com_atlassian_clover.TestNameSniffer __CLR4_4_1_TEST_NAME_SNIFFER=com_atlassian_clover.TestNameSniffer.NULL_INSTANCE;</span>

<span class="fc" id="L89">    private static final String[] EMPTY_STRING_ARRAY = {};</span>

    private static final String EMPTY_STRING = &quot;&quot;;

    private static final int NOT_FOUND = -1;

    /**
     * The extension separator character.
     * @since 1.4
     */
    public static final char EXTENSION_SEPARATOR = '.';

    /**
     * The extension separator String.
     * @since 1.4
     */
<span class="fc" id="L105">    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);</span>

    /**
     * The Unix separator character.
     */
    private static final char UNIX_SEPARATOR = '/';

    /**
     * The Windows separator character.
     */
    private static final char WINDOWS_SEPARATOR = '\\';

    /**
     * The system separator character.
     */
<span class="fc" id="L120">    private static final char SYSTEM_SEPARATOR = File.separatorChar;</span>

    /**
     * The separator character that is the opposite of the system separator.
     */
    private static final char OTHER_SEPARATOR;
<span class="fc" id="L126">    static {try{__CLR4_4_11a31a3kylvdytv.R.inc(1659);</span>
<span class="pc bpc" id="L127" title="7 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1660);if ((((isSystemWindows())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1661)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1662)==0&amp;false))) {{</span>
<span class="nc" id="L128">            __CLR4_4_11a31a3kylvdytv.R.inc(1663);OTHER_SEPARATOR = UNIX_SEPARATOR;</span>
        } }else {{
<span class="fc" id="L130">            __CLR4_4_11a31a3kylvdytv.R.inc(1664);OTHER_SEPARATOR = WINDOWS_SEPARATOR;</span>
        }
<span class="fc" id="L132">    }}finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Instances should NOT be constructed in standard programming.
     */
<span class="nc" id="L137">    public FilenameUtils() {try{__CLR4_4_11a31a3kylvdytv.R.inc(1665);</span>
<span class="nc" id="L138">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Determines if Windows file system is in use.
     *
     * @return true if the system is Windows
     */
<span class="fc" id="L145">    static boolean isSystemWindows() {try{__CLR4_4_11a31a3kylvdytv.R.inc(1666);</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1667);return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;</span>
<span class="fc" id="L147">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks if the character is a separator.
     *
     * @param ch  the character to check
     * @return true if it is a separator character
     */
<span class="fc" id="L155">    private static boolean isSeparator(final char ch) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1668);</span>
<span class="fc bfc" id="L156" title="All 4 branches covered.">        __CLR4_4_11a31a3kylvdytv.R.inc(1669);return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;</span>
<span class="fc" id="L157">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Normalizes a path, removing double and single dot path steps.
     * &lt;p&gt;
     * This method normalizes a path to a standard format.
     * The input may contain separators in either Unix or Windows format.
     * The output will contain separators in the format of the system.
     * &lt;p&gt;
     * A trailing slash will be retained.
     * A double slash will be merged to a single slash (but UNC names are handled).
     * A single dot path segment will be removed.
     * A double dot will cause that path segment and the one before to be removed.
     * If the double dot has no parent path segment to work with, {@code null}
     * is returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows except
     * for the separator character.
     * &lt;pre&gt;
     * /foo//               --&amp;gt;   /foo/
     * /foo/./              --&amp;gt;   /foo/
     * /foo/../bar          --&amp;gt;   /bar
     * /foo/../bar/         --&amp;gt;   /bar/
     * /foo/../bar/../baz   --&amp;gt;   /baz
     * //foo//./bar         --&amp;gt;   /foo/bar
     * /../                 --&amp;gt;   null
     * ../foo               --&amp;gt;   null
     * foo/bar/..           --&amp;gt;   foo/
     * foo/../../bar        --&amp;gt;   null
     * foo/../bar           --&amp;gt;   bar
     * //server/foo/../bar  --&amp;gt;   //server/bar
     * //server/../bar      --&amp;gt;   null
     * C:\foo\..\bar        --&amp;gt;   C:\bar
     * C:\..\bar            --&amp;gt;   null
     * ~/foo/../bar/        --&amp;gt;   ~/bar/
     * ~/../bar             --&amp;gt;   null
     * &lt;/pre&gt;
     * (Note the file separator returned will be correct for Windows/Unix)
     *
     * @param fileName  the fileName to normalize, null returns null
     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed
     */
<span class="fc" id="L199">    public static String normalize(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1670);</span>
<span class="fc" id="L200">        __CLR4_4_11a31a3kylvdytv.R.inc(1671);return doNormalize(fileName, SYSTEM_SEPARATOR, true);</span>
<span class="fc" id="L201">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>
    /**
     * Normalizes a path, removing double and single dot path steps.
     * &lt;p&gt;
     * This method normalizes a path to a standard format.
     * The input may contain separators in either Unix or Windows format.
     * The output will contain separators in the format specified.
     * &lt;p&gt;
     * A trailing slash will be retained.
     * A double slash will be merged to a single slash (but UNC names are handled).
     * A single dot path segment will be removed.
     * A double dot will cause that path segment and the one before to be removed.
     * If the double dot has no parent path segment to work with, {@code null}
     * is returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows except
     * for the separator character.
     * &lt;pre&gt;
     * /foo//               --&amp;gt;   /foo/
     * /foo/./              --&amp;gt;   /foo/
     * /foo/../bar          --&amp;gt;   /bar
     * /foo/../bar/         --&amp;gt;   /bar/
     * /foo/../bar/../baz   --&amp;gt;   /baz
     * //foo//./bar         --&amp;gt;   /foo/bar
     * /../                 --&amp;gt;   null
     * ../foo               --&amp;gt;   null
     * foo/bar/..           --&amp;gt;   foo/
     * foo/../../bar        --&amp;gt;   null
     * foo/../bar           --&amp;gt;   bar
     * //server/foo/../bar  --&amp;gt;   //server/bar
     * //server/../bar      --&amp;gt;   null
     * C:\foo\..\bar        --&amp;gt;   C:\bar
     * C:\..\bar            --&amp;gt;   null
     * ~/foo/../bar/        --&amp;gt;   ~/bar/
     * ~/../bar             --&amp;gt;   null
     * &lt;/pre&gt;
     * The output will be the same on both Unix and Windows including
     * the separator character.
     *
     * @param fileName  the fileName to normalize, null returns null
     * @param unixSeparator {@code true} if a unix separator should
     * be used or {@code false} if a windows separator should be used.
     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed
     * @since 2.0
     */
<span class="fc" id="L246">    public static String normalize(final String fileName, final boolean unixSeparator) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1672);</span>
<span class="pc bpc" id="L247" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1673);final char separator = (((unixSeparator )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1674)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1675)==0&amp;false))? UNIX_SEPARATOR : WINDOWS_SEPARATOR;</span>
<span class="fc" id="L248">        __CLR4_4_11a31a3kylvdytv.R.inc(1676);return doNormalize(fileName, separator, true);</span>
<span class="fc" id="L249">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Normalizes a path, removing double and single dot path steps,
     * and removing any final directory separator.
     * &lt;p&gt;
     * This method normalizes a path to a standard format.
     * The input may contain separators in either Unix or Windows format.
     * The output will contain separators in the format of the system.
     * &lt;p&gt;
     * A trailing slash will be removed.
     * A double slash will be merged to a single slash (but UNC names are handled).
     * A single dot path segment will be removed.
     * A double dot will cause that path segment and the one before to be removed.
     * If the double dot has no parent path segment to work with, {@code null}
     * is returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows except
     * for the separator character.
     * &lt;pre&gt;
     * /foo//               --&amp;gt;   /foo
     * /foo/./              --&amp;gt;   /foo
     * /foo/../bar          --&amp;gt;   /bar
     * /foo/../bar/         --&amp;gt;   /bar
     * /foo/../bar/../baz   --&amp;gt;   /baz
     * //foo//./bar         --&amp;gt;   /foo/bar
     * /../                 --&amp;gt;   null
     * ../foo               --&amp;gt;   null
     * foo/bar/..           --&amp;gt;   foo
     * foo/../../bar        --&amp;gt;   null
     * foo/../bar           --&amp;gt;   bar
     * //server/foo/../bar  --&amp;gt;   //server/bar
     * //server/../bar      --&amp;gt;   null
     * C:\foo\..\bar        --&amp;gt;   C:\bar
     * C:\..\bar            --&amp;gt;   null
     * ~/foo/../bar/        --&amp;gt;   ~/bar
     * ~/../bar             --&amp;gt;   null
     * &lt;/pre&gt;
     * (Note the file separator returned will be correct for Windows/Unix)
     *
     * @param fileName  the fileName to normalize, null returns null
     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed
     */
<span class="fc" id="L292">    public static String normalizeNoEndSeparator(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1677);</span>
<span class="fc" id="L293">        __CLR4_4_11a31a3kylvdytv.R.inc(1678);return doNormalize(fileName, SYSTEM_SEPARATOR, false);</span>
<span class="fc" id="L294">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Normalizes a path, removing double and single dot path steps,
     * and removing any final directory separator.
     * &lt;p&gt;
     * This method normalizes a path to a standard format.
     * The input may contain separators in either Unix or Windows format.
     * The output will contain separators in the format specified.
     * &lt;p&gt;
     * A trailing slash will be removed.
     * A double slash will be merged to a single slash (but UNC names are handled).
     * A single dot path segment will be removed.
     * A double dot will cause that path segment and the one before to be removed.
     * If the double dot has no parent path segment to work with, {@code null}
     * is returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows including
     * the separator character.
     * &lt;pre&gt;
     * /foo//               --&amp;gt;   /foo
     * /foo/./              --&amp;gt;   /foo
     * /foo/../bar          --&amp;gt;   /bar
     * /foo/../bar/         --&amp;gt;   /bar
     * /foo/../bar/../baz   --&amp;gt;   /baz
     * //foo//./bar         --&amp;gt;   /foo/bar
     * /../                 --&amp;gt;   null
     * ../foo               --&amp;gt;   null
     * foo/bar/..           --&amp;gt;   foo
     * foo/../../bar        --&amp;gt;   null
     * foo/../bar           --&amp;gt;   bar
     * //server/foo/../bar  --&amp;gt;   //server/bar
     * //server/../bar      --&amp;gt;   null
     * C:\foo\..\bar        --&amp;gt;   C:\bar
     * C:\..\bar            --&amp;gt;   null
     * ~/foo/../bar/        --&amp;gt;   ~/bar
     * ~/../bar             --&amp;gt;   null
     * &lt;/pre&gt;
     *
     * @param fileName  the fileName to normalize, null returns null
     * @param unixSeparator {@code true} if a unix separator should
     * be used or {@code false} if a windows separator should be used.
     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed
     * @since 2.0
     */
<span class="fc" id="L339">    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1679);</span>
<span class="pc bpc" id="L340" title="4 of 10 branches missed.">         __CLR4_4_11a31a3kylvdytv.R.inc(1680);final char separator = (((unixSeparator )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1681)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1682)==0&amp;false))? UNIX_SEPARATOR : WINDOWS_SEPARATOR;</span>
<span class="fc" id="L341">        __CLR4_4_11a31a3kylvdytv.R.inc(1683);return doNormalize(fileName, separator, false);</span>
<span class="fc" id="L342">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Internal method to perform the normalization.
     *
     * @param fileName  the fileName
     * @param separator The separator character to use
     * @param keepSeparator  true to keep the final separator
     * @return the normalized fileName. Null bytes inside string will be removed.
     */
<span class="fc" id="L352">    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1684);</span>
<span class="pc bpc" id="L353" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1685);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1686)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1687)==0&amp;false))) {{</span>
<span class="fc" id="L354">            __CLR4_4_11a31a3kylvdytv.R.inc(1688);return null;</span>
        }

<span class="fc" id="L357">        }__CLR4_4_11a31a3kylvdytv.R.inc(1689);requireNonNullChars(fileName);</span>

<span class="fc" id="L359">        __CLR4_4_11a31a3kylvdytv.R.inc(1690);int size = fileName.length();</span>
<span class="pc bpc" id="L360" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1691);if ((((size == 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1692)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1693)==0&amp;false))) {{</span>
<span class="fc" id="L361">            __CLR4_4_11a31a3kylvdytv.R.inc(1694);return fileName;</span>
        }
<span class="fc" id="L363">        }__CLR4_4_11a31a3kylvdytv.R.inc(1695);final int prefix = getPrefixLength(fileName);</span>
<span class="pc bpc" id="L364" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1696);if ((((prefix &lt; 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1697)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1698)==0&amp;false))) {{</span>
<span class="fc" id="L365">            __CLR4_4_11a31a3kylvdytv.R.inc(1699);return null;</span>
        }

<span class="fc" id="L368">        }__CLR4_4_11a31a3kylvdytv.R.inc(1700);final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy</span>
<span class="fc" id="L369">        __CLR4_4_11a31a3kylvdytv.R.inc(1701);fileName.getChars(0, fileName.length(), array, 0);</span>

        // fix separators throughout
<span class="pc bpc" id="L372" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1702);final char otherSeparator = (((separator == SYSTEM_SEPARATOR )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1703)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1704)==0&amp;false))? OTHER_SEPARATOR : SYSTEM_SEPARATOR;</span>
<span class="pc bpc" id="L373" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1705);for (int i = 0; (((i &lt; array.length)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1706)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1707)==0&amp;false)); i++) {{</span>
<span class="pc bpc" id="L374" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1708);if ((((array[i] == otherSeparator)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1709)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1710)==0&amp;false))) {{</span>
<span class="fc" id="L375">                __CLR4_4_11a31a3kylvdytv.R.inc(1711);array[i] = separator;</span>
            }
        }}

        // add extra separator on the end to simplify code below
<span class="fc" id="L380">        }__CLR4_4_11a31a3kylvdytv.R.inc(1712);boolean lastIsDirectory = true;</span>
<span class="pc bpc" id="L381" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1713);if ((((array[size - 1] != separator)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1714)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1715)==0&amp;false))) {{</span>
<span class="fc" id="L382">            __CLR4_4_11a31a3kylvdytv.R.inc(1716);array[size++] = separator;</span>
<span class="fc" id="L383">            __CLR4_4_11a31a3kylvdytv.R.inc(1717);lastIsDirectory = false;</span>
        }

        // adjoining slashes
        // If we get here, prefix can only be 0 or greater, size 1 or greater
        // If prefix is 0, set loop start to 1 to prevent index errors
<span class="pc bpc" id="L389" title="8 of 20 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1718);for (int i = ((((prefix != 0) )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1719)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1720)==0&amp;false))? prefix : 1; (((i &lt; size)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1721)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1722)==0&amp;false)); i++) {{</span>
<span class="pc bpc" id="L390" title="4 of 12 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1723);if ((((array[i] == separator &amp;&amp; array[i - 1] == separator)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1724)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1725)==0&amp;false))) {{</span>
<span class="fc" id="L391">                __CLR4_4_11a31a3kylvdytv.R.inc(1726);System.arraycopy(array, i, array, i - 1, size - i);</span>
<span class="fc" id="L392">                __CLR4_4_11a31a3kylvdytv.R.inc(1727);size--;</span>
<span class="fc" id="L393">                __CLR4_4_11a31a3kylvdytv.R.inc(1728);i--;</span>
            }
        }}

        // dot slash
<span class="pc bpc" id="L398" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1729);for (int i = prefix + 1; (((i &lt; size)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1730)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1731)==0&amp;false)); i++) {{</span>
<span class="fc bfc" id="L399" title="All 8 branches covered.">            __CLR4_4_11a31a3kylvdytv.R.inc(1732);if ((((array[i] == separator &amp;&amp; array[i - 1] == '.' &amp;&amp;</span>
<span class="pc bpc" id="L400" title="4 of 8 branches missed.">                    (i == prefix + 1 || array[i - 2] == separator))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1733)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1734)==0&amp;false))) {{</span>
<span class="pc bpc" id="L401" title="4 of 10 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(1735);if ((((i == size - 1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1736)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1737)==0&amp;false))) {{</span>
<span class="fc" id="L402">                    __CLR4_4_11a31a3kylvdytv.R.inc(1738);lastIsDirectory = true;</span>
                }
<span class="fc" id="L404">                }__CLR4_4_11a31a3kylvdytv.R.inc(1739);System.arraycopy(array, i + 1, array, i - 1, size - i);</span>
<span class="fc" id="L405">                __CLR4_4_11a31a3kylvdytv.R.inc(1740);size -=2;</span>
<span class="fc" id="L406">                __CLR4_4_11a31a3kylvdytv.R.inc(1741);i--;</span>
            }
        }}

        // double dot slash
<span class="fc" id="L411">        }__CLR4_4_11a31a3kylvdytv.R.inc(1742);outer:</span>
<span class="pc bpc" id="L412" title="4 of 10 branches missed.">        for (int i = prefix + 2; (((i &lt; size)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1743)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1744)==0&amp;false)); i++) {{</span>
<span class="pc bpc" id="L413" title="2 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1745);if ((((array[i] == separator &amp;&amp; array[i - 1] == '.' &amp;&amp; array[i - 2] == '.' &amp;&amp;</span>
<span class="pc bpc" id="L414" title="4 of 8 branches missed.">                    (i == prefix + 2 || array[i - 3] == separator))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1746)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1747)==0&amp;false))) {{</span>
<span class="pc bpc" id="L415" title="4 of 10 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(1748);if ((((i == prefix + 2)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1749)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1750)==0&amp;false))) {{</span>
<span class="fc" id="L416">                    __CLR4_4_11a31a3kylvdytv.R.inc(1751);return null;</span>
                }
<span class="pc bpc" id="L418" title="4 of 10 branches missed.">                }__CLR4_4_11a31a3kylvdytv.R.inc(1752);if ((((i == size - 1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1753)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1754)==0&amp;false))) {{</span>
<span class="fc" id="L419">                    __CLR4_4_11a31a3kylvdytv.R.inc(1755);lastIsDirectory = true;</span>
                }
<span class="fc" id="L421">                }__CLR4_4_11a31a3kylvdytv.R.inc(1756);int j;</span>
<span class="pc bpc" id="L422" title="4 of 10 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(1757);for (j = i - 4 ; (((j &gt;= prefix)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1758)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1759)==0&amp;false)); j--) {{</span>
<span class="pc bpc" id="L423" title="4 of 10 branches missed.">                    __CLR4_4_11a31a3kylvdytv.R.inc(1760);if ((((array[j] == separator)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1761)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1762)==0&amp;false))) {{</span>
                        // remove b/../ from a/b/../c
<span class="fc" id="L425">                        __CLR4_4_11a31a3kylvdytv.R.inc(1763);System.arraycopy(array, i + 1, array, j + 1, size - i);</span>
<span class="fc" id="L426">                        __CLR4_4_11a31a3kylvdytv.R.inc(1764);size -= i - j;</span>
<span class="fc" id="L427">                        __CLR4_4_11a31a3kylvdytv.R.inc(1765);i = j + 1;</span>
<span class="fc" id="L428">                        __CLR4_4_11a31a3kylvdytv.R.inc(1766);continue outer;</span>
                    }
                }}
                // remove a/../ from a/../c
<span class="fc" id="L432">                }__CLR4_4_11a31a3kylvdytv.R.inc(1767);System.arraycopy(array, i + 1, array, prefix, size - i);</span>
<span class="fc" id="L433">                __CLR4_4_11a31a3kylvdytv.R.inc(1768);size -= i + 1 - prefix;</span>
<span class="fc" id="L434">                __CLR4_4_11a31a3kylvdytv.R.inc(1769);i = prefix + 1;</span>
            }
        }}

<span class="pc bpc" id="L438" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1770);if ((((size &lt;= 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1771)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1772)==0&amp;false))) {{  // should never be less than 0</span>
<span class="fc" id="L439">            __CLR4_4_11a31a3kylvdytv.R.inc(1773);return EMPTY_STRING;</span>
        }
<span class="pc bpc" id="L441" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1774);if ((((size &lt;= prefix)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1775)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1776)==0&amp;false))) {{  // should never be less than prefix</span>
<span class="fc" id="L442">            __CLR4_4_11a31a3kylvdytv.R.inc(1777);return new String(array, 0, size);</span>
        }
<span class="pc bpc" id="L444" title="4 of 12 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1778);if ((((lastIsDirectory &amp;&amp; keepSeparator)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1779)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1780)==0&amp;false))) {{</span>
<span class="fc" id="L445">            __CLR4_4_11a31a3kylvdytv.R.inc(1781);return new String(array, 0, size);  // keep trailing separator</span>
        }
<span class="fc" id="L447">        }__CLR4_4_11a31a3kylvdytv.R.inc(1782);return new String(array, 0, size - 1);  // lose trailing separator</span>
<span class="fc" id="L448">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Concatenates a fileName to a base path using normal command line style rules.
     * &lt;p&gt;
     * The effect is equivalent to resultant directory after changing
     * directory to the first argument, followed by changing directory to
     * the second argument.
     * &lt;p&gt;
     * The first argument is the base path, the second is the path to concatenate.
     * The returned path is always normalized via {@link #normalize(String)},
     * thus {@code ..} is handled.
     * &lt;p&gt;
     * If {@code pathToAdd} is absolute (has an absolute prefix), then
     * it will be normalized and returned.
     * Otherwise, the paths will be joined, normalized and returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows except
     * for the separator character.
     * &lt;pre&gt;
     * /foo/      + bar        --&amp;gt;  /foo/bar
     * /foo       + bar        --&amp;gt;  /foo/bar
     * /foo       + /bar       --&amp;gt;  /bar
     * /foo       + C:/bar     --&amp;gt;  C:/bar
     * /foo       + C:bar      --&amp;gt;  C:bar (*)
     * /foo/a/    + ../bar     --&amp;gt;  /foo/bar
     * /foo/      + ../../bar  --&amp;gt;  null
     * /foo/      + /bar       --&amp;gt;  /bar
     * /foo/..    + /bar       --&amp;gt;  /bar
     * /foo       + bar/c.txt  --&amp;gt;  /foo/bar/c.txt
     * /foo/c.txt + bar        --&amp;gt;  /foo/c.txt/bar (!)
     * &lt;/pre&gt;
     * (*) Note that the Windows relative drive prefix is unreliable when
     * used with this method.
     * (!) Note that the first parameter must be a path. If it ends with a name, then
     * the name will be built into the concatenated path. If this might be a problem,
     * use {@link #getFullPath(String)} on the base path argument.
     *
     * @param basePath  the base path to attach to, always treated as a path
     * @param fullFileNameToAdd  the fileName (or path) to attach to the base
     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed
     */
<span class="fc" id="L490">    public static String concat(final String basePath, final String fullFileNameToAdd) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1783);</span>
<span class="fc" id="L491">        __CLR4_4_11a31a3kylvdytv.R.inc(1784);final int prefix = getPrefixLength(fullFileNameToAdd);</span>
<span class="pc bpc" id="L492" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1785);if ((((prefix &lt; 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1786)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1787)==0&amp;false))) {{</span>
<span class="fc" id="L493">            __CLR4_4_11a31a3kylvdytv.R.inc(1788);return null;</span>
        }
<span class="pc bpc" id="L495" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1789);if ((((prefix &gt; 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1790)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1791)==0&amp;false))) {{</span>
<span class="fc" id="L496">            __CLR4_4_11a31a3kylvdytv.R.inc(1792);return normalize(fullFileNameToAdd);</span>
        }
<span class="pc bpc" id="L498" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1793);if ((((basePath == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1794)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1795)==0&amp;false))) {{</span>
<span class="fc" id="L499">            __CLR4_4_11a31a3kylvdytv.R.inc(1796);return null;</span>
        }
<span class="fc" id="L501">        }__CLR4_4_11a31a3kylvdytv.R.inc(1797);final int len = basePath.length();</span>
<span class="pc bpc" id="L502" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1798);if ((((len == 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1799)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1800)==0&amp;false))) {{</span>
<span class="fc" id="L503">            __CLR4_4_11a31a3kylvdytv.R.inc(1801);return normalize(fullFileNameToAdd);</span>
        }
<span class="fc" id="L505">        }__CLR4_4_11a31a3kylvdytv.R.inc(1802);final char ch = basePath.charAt(len - 1);</span>
<span class="pc bpc" id="L506" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1803);if ((((isSeparator(ch))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1804)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1805)==0&amp;false))) {{</span>
<span class="fc" id="L507">            __CLR4_4_11a31a3kylvdytv.R.inc(1806);return normalize(basePath + fullFileNameToAdd);</span>
        }
<span class="fc" id="L509">        }__CLR4_4_11a31a3kylvdytv.R.inc(1807);return normalize(basePath + '/' + fullFileNameToAdd);</span>
<span class="fc" id="L510">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).
     * &lt;p&gt;
     * The files names are expected to be normalized.
     * &lt;/p&gt;
     *
     * Edge cases:
     * &lt;ul&gt;
     * &lt;li&gt;A {@code directory} must not be null: if null, throw IllegalArgumentException&lt;/li&gt;
     * &lt;li&gt;A directory does not contain itself: return false&lt;/li&gt;
     * &lt;li&gt;A null child file is not contained in any parent: return false&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param canonicalParent
     *            the file to consider as the parent.
     * @param canonicalChild
     *            the file to consider as the child.
     * @return true is the candidate leaf is under by the specified composite. False otherwise.
     * @since 2.2
     * @see FileUtils#directoryContains(File, File)
     */
<span class="fc" id="L533">    public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1808);</span>
<span class="fc" id="L534">        __CLR4_4_11a31a3kylvdytv.R.inc(1809);Objects.requireNonNull(canonicalParent, &quot;canonicalParent&quot;);</span>

<span class="pc bpc" id="L536" title="7 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1810);if ((((canonicalChild == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1811)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1812)==0&amp;false))) {{</span>
<span class="nc" id="L537">            __CLR4_4_11a31a3kylvdytv.R.inc(1813);return false;</span>
        }

<span class="pc bpc" id="L540" title="7 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1814);if ((((IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1815)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1816)==0&amp;false))) {{</span>
<span class="nc" id="L541">            __CLR4_4_11a31a3kylvdytv.R.inc(1817);return false;</span>
        }

<span class="fc" id="L544">        }__CLR4_4_11a31a3kylvdytv.R.inc(1818);return IOCase.SYSTEM.checkStartsWith(canonicalChild, canonicalParent);</span>
<span class="fc" id="L545">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Converts all separators to the Unix separator of forward slash.
     *
     * @param path  the path to be changed, null ignored
     * @return the updated path
     */
<span class="fc" id="L553">    public static String separatorsToUnix(final String path) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1819);</span>
<span class="pc bpc" id="L554" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1820);if ((((path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1821)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1822)==0&amp;false))) {{</span>
<span class="fc" id="L555">            __CLR4_4_11a31a3kylvdytv.R.inc(1823);return path;</span>
        }
<span class="fc" id="L557">        }__CLR4_4_11a31a3kylvdytv.R.inc(1824);return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);</span>
<span class="fc" id="L558">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Converts all separators to the Windows separator of backslash.
     *
     * @param path  the path to be changed, null ignored
     * @return the updated path
     */
<span class="fc" id="L566">    public static String separatorsToWindows(final String path) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1825);</span>
<span class="pc bpc" id="L567" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1826);if ((((path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1827)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1828)==0&amp;false))) {{</span>
<span class="fc" id="L568">            __CLR4_4_11a31a3kylvdytv.R.inc(1829);return path;</span>
        }
<span class="fc" id="L570">        }__CLR4_4_11a31a3kylvdytv.R.inc(1830);return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);</span>
<span class="fc" id="L571">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Converts all separators to the system separator.
     *
     * @param path  the path to be changed, null ignored
     * @return the updated path
     */
<span class="fc" id="L579">    public static String separatorsToSystem(final String path) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1831);</span>
<span class="pc bpc" id="L580" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1832);if ((((path == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1833)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1834)==0&amp;false))) {{</span>
<span class="fc" id="L581">            __CLR4_4_11a31a3kylvdytv.R.inc(1835);return null;</span>
        }
<span class="pc bpc" id="L583" title="7 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1836);return (((isSystemWindows() )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1837)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1838)==0&amp;false))? separatorsToWindows(path) : separatorsToUnix(path);</span>
<span class="fc" id="L584">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * &lt;p&gt;
     * The prefix length includes the first slash in the full fileName
     * if applicable. Thus, it is possible that the length returned is greater
     * than the length of the input string.
     * &lt;pre&gt;
     * Windows:
     * a\b\c.txt           --&amp;gt; 0           --&amp;gt; relative
     * \a\b\c.txt          --&amp;gt; 1           --&amp;gt; current drive absolute
     * C:a\b\c.txt         --&amp;gt; 2           --&amp;gt; drive relative
     * C:\a\b\c.txt        --&amp;gt; 3           --&amp;gt; absolute
     * \\server\a\b\c.txt  --&amp;gt; 9           --&amp;gt; UNC
     * \\\a\b\c.txt        --&amp;gt; -1          --&amp;gt; error
     *
     * Unix:
     * a/b/c.txt           --&amp;gt; 0           --&amp;gt; relative
     * /a/b/c.txt          --&amp;gt; 1           --&amp;gt; absolute
     * ~/a/b/c.txt         --&amp;gt; 2           --&amp;gt; current user
     * ~                   --&amp;gt; 2           --&amp;gt; current user (slash added)
     * ~user/a/b/c.txt     --&amp;gt; 6           --&amp;gt; named user
     * ~user               --&amp;gt; 6           --&amp;gt; named user (slash added)
     * //server/a/b/c.txt  --&amp;gt; 9
     * ///a/b/c.txt        --&amp;gt; -1          --&amp;gt; error
     * C:                  --&amp;gt; 0           --&amp;gt; valid filename as only null byte and / are reserved characters
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * ie. both Unix and Windows prefixes are matched regardless.
     *
     * Note that a leading // (or \\) is used to indicate a UNC name on Windows.
     * These must be followed by a server name, so double-slashes are not collapsed
     * to a single slash at the start of the fileName.
     *
     * @param fileName  the fileName to find the prefix in, null returns -1
     * @return the length of the prefix, -1 if invalid or null
     */
<span class="fc" id="L625">    public static int getPrefixLength(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1839);</span>
<span class="pc bpc" id="L626" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1840);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1841)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1842)==0&amp;false))) {{</span>
<span class="fc" id="L627">            __CLR4_4_11a31a3kylvdytv.R.inc(1843);return NOT_FOUND;</span>
        }
<span class="fc" id="L629">        }__CLR4_4_11a31a3kylvdytv.R.inc(1844);final int len = fileName.length();</span>
<span class="pc bpc" id="L630" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1845);if ((((len == 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1846)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1847)==0&amp;false))) {{</span>
<span class="fc" id="L631">            __CLR4_4_11a31a3kylvdytv.R.inc(1848);return 0;</span>
        }
<span class="fc" id="L633">        }__CLR4_4_11a31a3kylvdytv.R.inc(1849);char ch0 = fileName.charAt(0);</span>
<span class="pc bpc" id="L634" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1850);if ((((ch0 == ':')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1851)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1852)==0&amp;false))) {{</span>
<span class="fc" id="L635">            __CLR4_4_11a31a3kylvdytv.R.inc(1853);return NOT_FOUND;</span>
        }
<span class="pc bpc" id="L637" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1854);if ((((len == 1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1855)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1856)==0&amp;false))) {{</span>
<span class="pc bpc" id="L638" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1857);if ((((ch0 == '~')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1858)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1859)==0&amp;false))) {{</span>
<span class="fc" id="L639">                __CLR4_4_11a31a3kylvdytv.R.inc(1860);return 2;  // return a length greater than the input</span>
            }
<span class="pc bpc" id="L641" title="4 of 10 branches missed.">            }__CLR4_4_11a31a3kylvdytv.R.inc(1861);return (((isSeparator(ch0) )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1862)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1863)==0&amp;false))? 1 : 0;</span>
        }
<span class="pc bpc" id="L643" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1864);if ((((ch0 == '~')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1865)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1866)==0&amp;false))) {{</span>
<span class="fc" id="L644">            __CLR4_4_11a31a3kylvdytv.R.inc(1867);int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);</span>
<span class="fc" id="L645">            __CLR4_4_11a31a3kylvdytv.R.inc(1868);int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);</span>
<span class="pc bpc" id="L646" title="4 of 12 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1869);if ((((posUnix == NOT_FOUND &amp;&amp; posWin == NOT_FOUND)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1870)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1871)==0&amp;false))) {{</span>
<span class="fc" id="L647">                __CLR4_4_11a31a3kylvdytv.R.inc(1872);return len + 1;  // return a length greater than the input</span>
            }
<span class="pc bpc" id="L649" title="4 of 10 branches missed.">            }__CLR4_4_11a31a3kylvdytv.R.inc(1873);posUnix = (((posUnix == NOT_FOUND )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1874)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1875)==0&amp;false))? posWin : posUnix;</span>
<span class="pc bpc" id="L650" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1876);posWin = (((posWin == NOT_FOUND )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1877)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1878)==0&amp;false))? posUnix : posWin;</span>
<span class="fc" id="L651">            __CLR4_4_11a31a3kylvdytv.R.inc(1879);return Math.min(posUnix, posWin) + 1;</span>
        }
<span class="fc" id="L653">        }__CLR4_4_11a31a3kylvdytv.R.inc(1880);final char ch1 = fileName.charAt(1);</span>
<span class="pc bpc" id="L654" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1881);if ((((ch1 == ':')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1882)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1883)==0&amp;false))) {{</span>
<span class="fc" id="L655">            __CLR4_4_11a31a3kylvdytv.R.inc(1884);ch0 = Character.toUpperCase(ch0);</span>
<span class="pc bpc" id="L656" title="5 of 12 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1885);if ((((ch0 &gt;= 'A' &amp;&amp; ch0 &lt;= 'Z')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1886)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1887)==0&amp;false))) {{</span>
<span class="pc bpc" id="L657" title="5 of 12 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(1888);if ((((len == 2 &amp;&amp; !FileSystem.getCurrent().supportsDriveLetter())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1889)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1890)==0&amp;false))) {{</span>
<span class="fc" id="L658">                    __CLR4_4_11a31a3kylvdytv.R.inc(1891);return 0;</span>
                }
<span class="pc bpc" id="L660" title="5 of 12 branches missed.">                }__CLR4_4_11a31a3kylvdytv.R.inc(1892);if ((((len == 2 || !isSeparator(fileName.charAt(2)))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1893)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1894)==0&amp;false))) {{</span>
<span class="fc" id="L661">                    __CLR4_4_11a31a3kylvdytv.R.inc(1895);return 2;</span>
                }
<span class="fc" id="L663">                }__CLR4_4_11a31a3kylvdytv.R.inc(1896);return 3;</span>
            }
<span class="pc bpc" id="L665" title="4 of 10 branches missed.">            }__CLR4_4_11a31a3kylvdytv.R.inc(1897);if ((((ch0 == UNIX_SEPARATOR)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1898)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1899)==0&amp;false))) {{</span>
<span class="fc" id="L666">                __CLR4_4_11a31a3kylvdytv.R.inc(1900);return 1;</span>
            }
<span class="fc" id="L668">            }__CLR4_4_11a31a3kylvdytv.R.inc(1901);return NOT_FOUND;</span>

        }
<span class="pc bpc" id="L671" title="4 of 12 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1902);if ((((!isSeparator(ch0) || !isSeparator(ch1))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1903)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1904)==0&amp;false))) {{</span>
<span class="pc bpc" id="L672" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1905);return (((isSeparator(ch0) )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1906)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1907)==0&amp;false))? 1 : 0;</span>
        }
<span class="fc" id="L674">        }__CLR4_4_11a31a3kylvdytv.R.inc(1908);int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);</span>
<span class="fc" id="L675">        __CLR4_4_11a31a3kylvdytv.R.inc(1909);int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);</span>
<span class="pc bpc" id="L676" title="4 of 16 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1910);if ((((posUnix == NOT_FOUND &amp;&amp; posWin == NOT_FOUND || posUnix == 2 || posWin == 2)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1911)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1912)==0&amp;false))) {{</span>
<span class="fc" id="L677">            __CLR4_4_11a31a3kylvdytv.R.inc(1913);return NOT_FOUND;</span>
        }
<span class="pc bpc" id="L679" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1914);posUnix = (((posUnix == NOT_FOUND )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1915)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1916)==0&amp;false))? posWin : posUnix;</span>
<span class="pc bpc" id="L680" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1917);posWin = (((posWin == NOT_FOUND )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1918)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1919)==0&amp;false))? posUnix : posWin;</span>
<span class="fc" id="L681">        __CLR4_4_11a31a3kylvdytv.R.inc(1920);final int pos = Math.min(posUnix, posWin) + 1;</span>
<span class="fc" id="L682">        __CLR4_4_11a31a3kylvdytv.R.inc(1921);final String hostnamePart = fileName.substring(2, pos - 1);</span>
<span class="pc bpc" id="L683" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1922);return (((isValidHostName(hostnamePart) )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1923)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1924)==0&amp;false))? pos : NOT_FOUND;</span>
<span class="fc" id="L684">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Returns the index of the last directory separator character.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The position of the last forward or backslash is returned.
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param fileName  the fileName to find the last path separator in, null returns -1
     * @return the index of the last separator character, or -1 if there
     * is no such character
     */
<span class="fc" id="L698">    public static int indexOfLastSeparator(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1925);</span>
<span class="pc bpc" id="L699" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1926);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1927)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1928)==0&amp;false))) {{</span>
<span class="fc" id="L700">            __CLR4_4_11a31a3kylvdytv.R.inc(1929);return NOT_FOUND;</span>
        }
<span class="fc" id="L702">        }__CLR4_4_11a31a3kylvdytv.R.inc(1930);final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);</span>
<span class="fc" id="L703">        __CLR4_4_11a31a3kylvdytv.R.inc(1931);final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);</span>
<span class="fc" id="L704">        __CLR4_4_11a31a3kylvdytv.R.inc(1932);return Math.max(lastUnixPos, lastWindowsPos);</span>
<span class="fc" id="L705">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Returns the index of the last extension separator character, which is a dot.
     * &lt;p&gt;
     * This method also checks that there is no directory separator after the last dot. To do this it uses
     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on, with the
     * exception of a possible {@link IllegalArgumentException} on Windows (see below).
     * &lt;/p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This method used to have a hidden problem for names like &quot;foo.exe:bar.txt&quot;.
     * In this case, the name wouldn't be the name of a file, but the identifier of an
     * alternate data stream (bar.txt) on the file foo.exe. The method used to return
     * &quot;.txt&quot; here, which would be misleading. Commons IO 2.7, and later versions, are throwing
     * an {@link IllegalArgumentException} for names like this.
     *
     * @param fileName
     *            the fileName to find the last extension separator in, null returns -1
     * @return the index of the last extension separator character, or -1 if there is no such character
     * @throws IllegalArgumentException &lt;b&gt;Windows only:&lt;/b&gt; The fileName parameter is, in fact,
     * the identifier of an Alternate Data Stream, for example &quot;foo.exe:bar.txt&quot;.
     */
<span class="fc" id="L729">    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {try{__CLR4_4_11a31a3kylvdytv.R.inc(1933);</span>
<span class="pc bpc" id="L730" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1934);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1935)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1936)==0&amp;false))) {{</span>
<span class="fc" id="L731">            __CLR4_4_11a31a3kylvdytv.R.inc(1937);return NOT_FOUND;</span>
        }
<span class="pc bpc" id="L733" title="7 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1938);if ((((isSystemWindows())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1939)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1940)==0&amp;false))) {{</span>
            // Special handling for NTFS ADS: Don't accept colon in the fileName.
<span class="nc" id="L735">            __CLR4_4_11a31a3kylvdytv.R.inc(1941);final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));</span>
<span class="nc bnc" id="L736" title="All 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(1942);if ((((offset != -1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1943)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1944)==0&amp;false))) {{</span>
<span class="nc" id="L737">                __CLR4_4_11a31a3kylvdytv.R.inc(1945);throw new IllegalArgumentException(&quot;NTFS ADS separator (':') in file name is forbidden.&quot;);</span>
            }
        }}
<span class="fc" id="L740">        }__CLR4_4_11a31a3kylvdytv.R.inc(1946);final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);</span>
<span class="fc" id="L741">        __CLR4_4_11a31a3kylvdytv.R.inc(1947);final int lastSeparator = indexOfLastSeparator(fileName);</span>
<span class="pc bpc" id="L742" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1948);return (((lastSeparator &gt; extensionPos )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1949)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1950)==0&amp;false))? NOT_FOUND : extensionPos;</span>
<span class="fc" id="L743">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the prefix from a full fileName, such as {@code C:/}
     * or {@code ~/}.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The prefix includes the first slash in the full fileName where applicable.
     * &lt;pre&gt;
     * Windows:
     * a\b\c.txt           --&amp;gt; &quot;&quot;          --&amp;gt; relative
     * \a\b\c.txt          --&amp;gt; &quot;\&quot;         --&amp;gt; current drive absolute
     * C:a\b\c.txt         --&amp;gt; &quot;C:&quot;        --&amp;gt; drive relative
     * C:\a\b\c.txt        --&amp;gt; &quot;C:\&quot;       --&amp;gt; absolute
     * \\server\a\b\c.txt  --&amp;gt; &quot;\\server\&quot; --&amp;gt; UNC
     *
     * Unix:
     * a/b/c.txt           --&amp;gt; &quot;&quot;          --&amp;gt; relative
     * /a/b/c.txt          --&amp;gt; &quot;/&quot;         --&amp;gt; absolute
     * ~/a/b/c.txt         --&amp;gt; &quot;~/&quot;        --&amp;gt; current user
     * ~                   --&amp;gt; &quot;~/&quot;        --&amp;gt; current user (slash added)
     * ~user/a/b/c.txt     --&amp;gt; &quot;~user/&quot;    --&amp;gt; named user
     * ~user               --&amp;gt; &quot;~user/&quot;    --&amp;gt; named user (slash added)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * ie. both Unix and Windows prefixes are matched regardless.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed
     */
<span class="fc" id="L774">    public static String getPrefix(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1951);</span>
<span class="pc bpc" id="L775" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1952);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1953)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1954)==0&amp;false))) {{</span>
<span class="fc" id="L776">            __CLR4_4_11a31a3kylvdytv.R.inc(1955);return null;</span>
        }
<span class="fc" id="L778">        }__CLR4_4_11a31a3kylvdytv.R.inc(1956);final int len = getPrefixLength(fileName);</span>
<span class="pc bpc" id="L779" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1957);if ((((len &lt; 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1958)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1959)==0&amp;false))) {{</span>
<span class="fc" id="L780">            __CLR4_4_11a31a3kylvdytv.R.inc(1960);return null;</span>
        }
<span class="pc bpc" id="L782" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(1961);if ((((len &gt; fileName.length())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1962)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1963)==0&amp;false))) {{</span>
<span class="fc" id="L783">            __CLR4_4_11a31a3kylvdytv.R.inc(1964);requireNonNullChars(fileName + UNIX_SEPARATOR);</span>
<span class="fc" id="L784">            __CLR4_4_11a31a3kylvdytv.R.inc(1965);return fileName + UNIX_SEPARATOR;</span>
        }
<span class="fc" id="L786">        }__CLR4_4_11a31a3kylvdytv.R.inc(1966);final String path = fileName.substring(0, len);</span>
<span class="fc" id="L787">        __CLR4_4_11a31a3kylvdytv.R.inc(1967);requireNonNullChars(path);</span>
<span class="fc" id="L788">        __CLR4_4_11a31a3kylvdytv.R.inc(1968);return path;</span>
<span class="fc" id="L789">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the path from a full fileName, which excludes the prefix.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before and
     * including the last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&amp;gt; a\b\
     * ~/a/b/c.txt  --&amp;gt; a/b/
     * a.txt        --&amp;gt; &quot;&quot;
     * a/b/c        --&amp;gt; a/b/
     * a/b/c/       --&amp;gt; a/b/c/
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * &lt;p&gt;
     * This method drops the prefix from the result.
     * See {@link #getFullPath(String)} for the method that retains the prefix.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid.
     * Null bytes inside string will be removed
     */
<span class="fc" id="L814">    public static String getPath(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1969);</span>
<span class="fc" id="L815">        __CLR4_4_11a31a3kylvdytv.R.inc(1970);return doGetPath(fileName, 1);</span>
<span class="fc" id="L816">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the path from a full fileName, which excludes the prefix, and
     * also excluding the final directory separator.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before the
     * last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&amp;gt; a\b
     * ~/a/b/c.txt  --&amp;gt; a/b
     * a.txt        --&amp;gt; &quot;&quot;
     * a/b/c        --&amp;gt; a/b
     * a/b/c/       --&amp;gt; a/b/c
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * &lt;p&gt;
     * This method drops the prefix from the result.
     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid.
     * Null bytes inside string will be removed
     */
<span class="fc" id="L842">    public static String getPathNoEndSeparator(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1971);</span>
<span class="fc" id="L843">        __CLR4_4_11a31a3kylvdytv.R.inc(1972);return doGetPath(fileName, 0);</span>
<span class="fc" id="L844">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Does the work of getting the path.
     *
     * @param fileName  the fileName
     * @param separatorAdd  0 to omit the end separator, 1 to return it
     * @return the path. Null bytes inside string will be removed
     */
<span class="fc" id="L853">    private static String doGetPath(final String fileName, final int separatorAdd) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1973);</span>
<span class="pc bpc" id="L854" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1974);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1975)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1976)==0&amp;false))) {{</span>
<span class="fc" id="L855">            __CLR4_4_11a31a3kylvdytv.R.inc(1977);return null;</span>
        }
<span class="fc" id="L857">        }__CLR4_4_11a31a3kylvdytv.R.inc(1978);final int prefix = getPrefixLength(fileName);</span>
<span class="pc bpc" id="L858" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1979);if ((((prefix &lt; 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1980)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1981)==0&amp;false))) {{</span>
<span class="fc" id="L859">            __CLR4_4_11a31a3kylvdytv.R.inc(1982);return null;</span>
        }
<span class="fc" id="L861">        }__CLR4_4_11a31a3kylvdytv.R.inc(1983);final int index = indexOfLastSeparator(fileName);</span>
<span class="fc" id="L862">        __CLR4_4_11a31a3kylvdytv.R.inc(1984);final int endIndex = index+separatorAdd;</span>
<span class="pc bpc" id="L863" title="4 of 14 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1985);if ((((prefix &gt;= fileName.length() || index &lt; 0 || prefix &gt;= endIndex)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1986)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1987)==0&amp;false))) {{</span>
<span class="fc" id="L864">            __CLR4_4_11a31a3kylvdytv.R.inc(1988);return EMPTY_STRING;</span>
        }
<span class="fc" id="L866">        }__CLR4_4_11a31a3kylvdytv.R.inc(1989);final String path = fileName.substring(prefix, endIndex);</span>
<span class="fc" id="L867">        __CLR4_4_11a31a3kylvdytv.R.inc(1990);requireNonNullChars(path);</span>
<span class="fc" id="L868">        __CLR4_4_11a31a3kylvdytv.R.inc(1991);return path;</span>
<span class="fc" id="L869">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the full path from a full fileName, which is the prefix + path.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before and
     * including the last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&amp;gt; C:\a\b\
     * ~/a/b/c.txt  --&amp;gt; ~/a/b/
     * a.txt        --&amp;gt; &quot;&quot;
     * a/b/c        --&amp;gt; a/b/
     * a/b/c/       --&amp;gt; a/b/c/
     * C:           --&amp;gt; C:
     * C:\          --&amp;gt; C:\
     * ~            --&amp;gt; ~/
     * ~/           --&amp;gt; ~/
     * ~user        --&amp;gt; ~user/
     * ~user/       --&amp;gt; ~user/
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid
     */
<span class="fc" id="L896">    public static String getFullPath(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1992);</span>
<span class="fc" id="L897">        __CLR4_4_11a31a3kylvdytv.R.inc(1993);return doGetFullPath(fileName, true);</span>
<span class="fc" id="L898">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the full path from a full fileName, which is the prefix + path,
     * and also excluding the final directory separator.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before the
     * last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&amp;gt; C:\a\b
     * ~/a/b/c.txt  --&amp;gt; ~/a/b
     * a.txt        --&amp;gt; &quot;&quot;
     * a/b/c        --&amp;gt; a/b
     * a/b/c/       --&amp;gt; a/b/c
     * C:           --&amp;gt; C:
     * C:\          --&amp;gt; C:\
     * ~            --&amp;gt; ~
     * ~/           --&amp;gt; ~
     * ~user        --&amp;gt; ~user
     * ~user/       --&amp;gt; ~user
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid
     */
<span class="fc" id="L926">    public static String getFullPathNoEndSeparator(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1994);</span>
<span class="fc" id="L927">        __CLR4_4_11a31a3kylvdytv.R.inc(1995);return doGetFullPath(fileName, false);</span>
<span class="fc" id="L928">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Does the work of getting the path.
     *
     * @param fileName  the fileName
     * @param includeSeparator  true to include the end separator
     * @return the path
     */
<span class="fc" id="L937">    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {try{__CLR4_4_11a31a3kylvdytv.R.inc(1996);</span>
<span class="pc bpc" id="L938" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(1997);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(1998)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(1999)==0&amp;false))) {{</span>
<span class="fc" id="L939">            __CLR4_4_11a31a3kylvdytv.R.inc(2000);return null;</span>
        }
<span class="fc" id="L941">        }__CLR4_4_11a31a3kylvdytv.R.inc(2001);final int prefix = getPrefixLength(fileName);</span>
<span class="pc bpc" id="L942" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2002);if ((((prefix &lt; 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2003)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2004)==0&amp;false))) {{</span>
<span class="fc" id="L943">            __CLR4_4_11a31a3kylvdytv.R.inc(2005);return null;</span>
        }
<span class="pc bpc" id="L945" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2006);if ((((prefix &gt;= fileName.length())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2007)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2008)==0&amp;false))) {{</span>
<span class="pc bpc" id="L946" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2009);if ((((includeSeparator)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2010)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2011)==0&amp;false))) {{</span>
<span class="fc" id="L947">                __CLR4_4_11a31a3kylvdytv.R.inc(2012);return getPrefix(fileName);  // add end slash if necessary</span>
            }
<span class="fc" id="L949">            }__CLR4_4_11a31a3kylvdytv.R.inc(2013);return fileName;</span>
        }
<span class="fc" id="L951">        }__CLR4_4_11a31a3kylvdytv.R.inc(2014);final int index = indexOfLastSeparator(fileName);</span>
<span class="pc bpc" id="L952" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2015);if ((((index &lt; 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2016)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2017)==0&amp;false))) {{</span>
<span class="fc" id="L953">            __CLR4_4_11a31a3kylvdytv.R.inc(2018);return fileName.substring(0, prefix);</span>
        }
<span class="pc bpc" id="L955" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2019);int end = index + ((((includeSeparator )&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2020)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2021)==0&amp;false))?  1 : 0);</span>
<span class="pc bpc" id="L956" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2022);if ((((end == 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2023)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2024)==0&amp;false))) {{</span>
<span class="fc" id="L957">            __CLR4_4_11a31a3kylvdytv.R.inc(2025);end++;</span>
        }
<span class="fc" id="L959">        }__CLR4_4_11a31a3kylvdytv.R.inc(2026);return fileName.substring(0, end);</span>
<span class="fc" id="L960">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the name minus the path from a full fileName.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The text after the last forward or backslash is returned.
     * &lt;pre&gt;
     * a/b/c.txt --&amp;gt; c.txt
     * a.txt     --&amp;gt; a.txt
     * a/b/c     --&amp;gt; c
     * a/b/c/    --&amp;gt; &quot;&quot;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the name of the file without the path, or an empty string if none exists.
     * Null bytes inside string will be removed
     */
<span class="fc" id="L980">    public static String getName(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2027);</span>
<span class="pc bpc" id="L981" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2028);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2029)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2030)==0&amp;false))) {{</span>
<span class="fc" id="L982">            __CLR4_4_11a31a3kylvdytv.R.inc(2031);return null;</span>
        }
<span class="fc" id="L984">        }__CLR4_4_11a31a3kylvdytv.R.inc(2032);requireNonNullChars(fileName);</span>
<span class="fc" id="L985">        __CLR4_4_11a31a3kylvdytv.R.inc(2033);final int index = indexOfLastSeparator(fileName);</span>
<span class="fc" id="L986">        __CLR4_4_11a31a3kylvdytv.R.inc(2034);return fileName.substring(index + 1);</span>
<span class="fc" id="L987">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks the input for null bytes, a sign of unsanitized data being passed to to file level functions.
     *
     * This may be used for poison byte attacks.
     *
     * @param path the path to check
     */
<span class="fc" id="L996">    private static void requireNonNullChars(final String path) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2035);</span>
<span class="pc bpc" id="L997" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2036);if ((((path.indexOf(0) &gt;= 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2037)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2038)==0&amp;false))) {{</span>
<span class="fc" id="L998">            __CLR4_4_11a31a3kylvdytv.R.inc(2039);throw new IllegalArgumentException(&quot;Null byte present in file/path name. There are no &quot;</span>
                + &quot;known legitimate use cases for such data, but several injection attacks may use it&quot;);
        }
<span class="fc" id="L1001">    }}finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the base name, minus the full path and extension, from a full fileName.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The text after the last forward or backslash and before the last dot is returned.
     * &lt;pre&gt;
     * a/b/c.txt --&amp;gt; c
     * a.txt     --&amp;gt; a
     * a/b/c     --&amp;gt; c
     * a/b/c/    --&amp;gt; &quot;&quot;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string
     * will be removed
     */
<span class="fc" id="L1021">    public static String getBaseName(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2040);</span>
<span class="fc" id="L1022">        __CLR4_4_11a31a3kylvdytv.R.inc(2041);return removeExtension(getName(fileName));</span>
<span class="fc" id="L1023">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Gets the extension of a fileName.
     * &lt;p&gt;
     * This method returns the textual part of the fileName after the last dot.
     * There must be no directory separator after the dot.
     * &lt;pre&gt;
     * foo.txt      --&amp;gt; &quot;txt&quot;
     * a/b/c.jpg    --&amp;gt; &quot;jpg&quot;
     * a/b.txt/c    --&amp;gt; &quot;&quot;
     * a/b/c        --&amp;gt; &quot;&quot;
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on, with the
     * exception of a possible {@link IllegalArgumentException} on Windows (see below).
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This method used to have a hidden problem for names like &quot;foo.exe:bar.txt&quot;.
     * In this case, the name wouldn't be the name of a file, but the identifier of an
     * alternate data stream (bar.txt) on the file foo.exe. The method used to return
     * &quot;.txt&quot; here, which would be misleading. Commons IO 2.7, and later versions, are throwing
     * an {@link IllegalArgumentException} for names like this.
     *
     * @param fileName the fileName to retrieve the extension of.
     * @return the extension of the file or an empty string if none exists or {@code null}
     * if the fileName is {@code null}.
     * @throws IllegalArgumentException &lt;b&gt;Windows only:&lt;/b&gt; The fileName parameter is, in fact,
     * the identifier of an Alternate Data Stream, for example &quot;foo.exe:bar.txt&quot;.
     */
<span class="fc" id="L1053">    public static String getExtension(final String fileName) throws IllegalArgumentException {try{__CLR4_4_11a31a3kylvdytv.R.inc(2042);</span>
<span class="pc bpc" id="L1054" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2043);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2044)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2045)==0&amp;false))) {{</span>
<span class="fc" id="L1055">            __CLR4_4_11a31a3kylvdytv.R.inc(2046);return null;</span>
        }
<span class="fc" id="L1057">        }__CLR4_4_11a31a3kylvdytv.R.inc(2047);final int index = indexOfExtension(fileName);</span>
<span class="pc bpc" id="L1058" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2048);if ((((index == NOT_FOUND)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2049)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2050)==0&amp;false))) {{</span>
<span class="fc" id="L1059">            __CLR4_4_11a31a3kylvdytv.R.inc(2051);return EMPTY_STRING;</span>
        }
<span class="fc" id="L1061">        }__CLR4_4_11a31a3kylvdytv.R.inc(2052);return fileName.substring(index + 1);</span>
<span class="fc" id="L1062">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Special handling for NTFS ADS: Don't accept colon in the fileName.
     *
     * @param fileName a file name
     * @return ADS offsets.
     */
<span class="nc" id="L1070">    private static int getAdsCriticalOffset(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2053);</span>
        // Step 1: Remove leading path segments.
<span class="nc" id="L1072">        __CLR4_4_11a31a3kylvdytv.R.inc(2054);final int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);</span>
<span class="nc" id="L1073">        __CLR4_4_11a31a3kylvdytv.R.inc(2055);final int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);</span>
<span class="nc bnc" id="L1074" title="All 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2056);if ((((offset1 == -1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2057)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2058)==0&amp;false))) {{</span>
<span class="nc bnc" id="L1075" title="All 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2059);if ((((offset2 == -1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2060)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2061)==0&amp;false))) {{</span>
<span class="nc" id="L1076">                __CLR4_4_11a31a3kylvdytv.R.inc(2062);return 0;</span>
            }
<span class="nc" id="L1078">            }__CLR4_4_11a31a3kylvdytv.R.inc(2063);return offset2 + 1;</span>
        }
<span class="nc bnc" id="L1080" title="All 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2064);if ((((offset2 == -1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2065)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2066)==0&amp;false))) {{</span>
<span class="nc" id="L1081">            __CLR4_4_11a31a3kylvdytv.R.inc(2067);return offset1 + 1;</span>
        }
<span class="nc" id="L1083">        }__CLR4_4_11a31a3kylvdytv.R.inc(2068);return Math.max(offset1, offset2) + 1;</span>
<span class="nc" id="L1084">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Removes the extension from a fileName.
     * &lt;p&gt;
     * This method returns the textual part of the fileName before the last dot.
     * There must be no directory separator after the dot.
     * &lt;pre&gt;
     * foo.txt    --&amp;gt; foo
     * a\b\c.jpg  --&amp;gt; a\b\c
     * a\b\c      --&amp;gt; a\b\c
     * a.b\c      --&amp;gt; a.b\c
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param fileName  the fileName to query, null returns null
     * @return the fileName minus the extension
     */
<span class="fc" id="L1103">    public static String removeExtension(final String fileName) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2069);</span>
<span class="pc bpc" id="L1104" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2070);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2071)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2072)==0&amp;false))) {{</span>
<span class="fc" id="L1105">            __CLR4_4_11a31a3kylvdytv.R.inc(2073);return null;</span>
        }
<span class="fc" id="L1107">        }__CLR4_4_11a31a3kylvdytv.R.inc(2074);requireNonNullChars(fileName);</span>

<span class="fc" id="L1109">        __CLR4_4_11a31a3kylvdytv.R.inc(2075);final int index = indexOfExtension(fileName);</span>
<span class="pc bpc" id="L1110" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2076);if ((((index == NOT_FOUND)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2077)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2078)==0&amp;false))) {{</span>
<span class="fc" id="L1111">            __CLR4_4_11a31a3kylvdytv.R.inc(2079);return fileName;</span>
        }
<span class="fc" id="L1113">        }__CLR4_4_11a31a3kylvdytv.R.inc(2080);return fileName.substring(0, index);</span>
<span class="fc" id="L1114">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether two fileNames are equal exactly.
     * &lt;p&gt;
     * No processing is performed on the fileNames other than comparison,
     * thus this is merely a null-safe case-sensitive equals.
     *
     * @param fileName1  the first fileName to query, may be null
     * @param fileName2  the second fileName to query, may be null
     * @return true if the fileNames are equal, null equals null
     * @see IOCase#SENSITIVE
     */
<span class="fc" id="L1127">    public static boolean equals(final String fileName1, final String fileName2) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2081);</span>
<span class="fc" id="L1128">        __CLR4_4_11a31a3kylvdytv.R.inc(2082);return equals(fileName1, fileName2, false, IOCase.SENSITIVE);</span>
<span class="fc" id="L1129">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether two fileNames are equal using the case rules of the system.
     * &lt;p&gt;
     * No processing is performed on the fileNames other than comparison.
     * The check is case-sensitive on Unix and case-insensitive on Windows.
     *
     * @param fileName1  the first fileName to query, may be null
     * @param fileName2  the second fileName to query, may be null
     * @return true if the fileNames are equal, null equals null
     * @see IOCase#SYSTEM
     */
<span class="fc" id="L1142">    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2083);</span>
<span class="fc" id="L1143">        __CLR4_4_11a31a3kylvdytv.R.inc(2084);return equals(fileName1, fileName2, false, IOCase.SYSTEM);</span>
<span class="fc" id="L1144">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether two fileNames are equal after both have been normalized.
     * &lt;p&gt;
     * Both fileNames are first passed to {@link #normalize(String)}.
     * The check is then performed in a case-sensitive manner.
     *
     * @param fileName1  the first fileName to query, may be null
     * @param fileName2  the second fileName to query, may be null
     * @return true if the fileNames are equal, null equals null
     * @see IOCase#SENSITIVE
     */
<span class="fc" id="L1157">    public static boolean equalsNormalized(final String fileName1, final String fileName2) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2085);</span>
<span class="fc" id="L1158">        __CLR4_4_11a31a3kylvdytv.R.inc(2086);return equals(fileName1, fileName2, true, IOCase.SENSITIVE);</span>
<span class="fc" id="L1159">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether two fileNames are equal after both have been normalized
     * and using the case rules of the system.
     * &lt;p&gt;
     * Both fileNames are first passed to {@link #normalize(String)}.
     * The check is then performed case-sensitive on Unix and
     * case-insensitive on Windows.
     *
     * @param fileName1  the first fileName to query, may be null
     * @param fileName2  the second fileName to query, may be null
     * @return true if the fileNames are equal, null equals null
     * @see IOCase#SYSTEM
     */
<span class="fc" id="L1174">    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2087);</span>
<span class="fc" id="L1175">        __CLR4_4_11a31a3kylvdytv.R.inc(2088);return equals(fileName1, fileName2, true, IOCase.SYSTEM);</span>
<span class="fc" id="L1176">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether two fileNames are equal, optionally normalizing and providing
     * control over the case-sensitivity.
     *
     * @param fileName1  the first fileName to query, may be null
     * @param fileName2  the second fileName to query, may be null
     * @param normalized  whether to normalize the fileNames
     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive
     * @return true if the fileNames are equal, null equals null
     * @since 1.3
     */
    public static boolean equals(
            String fileName1, String fileName2,
<span class="fc" id="L1191">            final boolean normalized, IOCase caseSensitivity) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2089);</span>

<span class="pc bpc" id="L1193" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2090);if ((((fileName1 == null || fileName2 == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2091)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2092)==0&amp;false))) {{</span>
<span class="fc bfc" id="L1194" title="All 4 branches covered.">            __CLR4_4_11a31a3kylvdytv.R.inc(2093);return fileName1 == null &amp;&amp; fileName2 == null;</span>
        }
<span class="pc bpc" id="L1196" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2094);if ((((normalized)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2095)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2096)==0&amp;false))) {{</span>
<span class="fc" id="L1197">            __CLR4_4_11a31a3kylvdytv.R.inc(2097);fileName1 = normalize(fileName1);</span>
<span class="pc bpc" id="L1198" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2098);if ((((fileName1 == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2099)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2100)==0&amp;false))) {{</span>
<span class="fc" id="L1199">                __CLR4_4_11a31a3kylvdytv.R.inc(2101);return false;</span>
            }
<span class="fc" id="L1201">            }__CLR4_4_11a31a3kylvdytv.R.inc(2102);fileName2 = normalize(fileName2);</span>
<span class="pc bpc" id="L1202" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2103);if ((((fileName2 == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2104)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2105)==0&amp;false))) {{</span>
<span class="fc" id="L1203">                __CLR4_4_11a31a3kylvdytv.R.inc(2106);return false;</span>
            }
        }}
<span class="pc bpc" id="L1206" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2107);if ((((caseSensitivity == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2108)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2109)==0&amp;false))) {{</span>
<span class="fc" id="L1207">            __CLR4_4_11a31a3kylvdytv.R.inc(2110);caseSensitivity = IOCase.SENSITIVE;</span>
        }
<span class="fc" id="L1209">        }__CLR4_4_11a31a3kylvdytv.R.inc(2111);return caseSensitivity.checkEquals(fileName1, fileName2);</span>
<span class="fc" id="L1210">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether the extension of the fileName is that specified.
     * &lt;p&gt;
     * This method obtains the extension as the textual part of the fileName
     * after the last dot. There must be no directory separator after the dot.
     * The extension check is case-sensitive on all platforms.
     *
     * @param fileName  the fileName to query, null returns false
     * @param extension  the extension to check for, null or empty checks for no extension
     * @return true if the fileName has the specified extension
     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes
     */
<span class="fc" id="L1224">    public static boolean isExtension(final String fileName, final String extension) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2112);</span>
<span class="pc bpc" id="L1225" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2113);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2114)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2115)==0&amp;false))) {{</span>
<span class="fc" id="L1226">            __CLR4_4_11a31a3kylvdytv.R.inc(2116);return false;</span>
        }
<span class="fc" id="L1228">        }__CLR4_4_11a31a3kylvdytv.R.inc(2117);requireNonNullChars(fileName);</span>

<span class="pc bpc" id="L1230" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2118);if ((((extension == null || extension.isEmpty())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2119)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2120)==0&amp;false))) {{</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">            __CLR4_4_11a31a3kylvdytv.R.inc(2121);return indexOfExtension(fileName) == NOT_FOUND;</span>
        }
<span class="fc" id="L1233">        }__CLR4_4_11a31a3kylvdytv.R.inc(2122);final String fileExt = getExtension(fileName);</span>
<span class="fc" id="L1234">        __CLR4_4_11a31a3kylvdytv.R.inc(2123);return fileExt.equals(extension);</span>
<span class="fc" id="L1235">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether the extension of the fileName is one of those specified.
     * &lt;p&gt;
     * This method obtains the extension as the textual part of the fileName
     * after the last dot. There must be no directory separator after the dot.
     * The extension check is case-sensitive on all platforms.
     *
     * @param fileName  the fileName to query, null returns false
     * @param extensions  the extensions to check for, null checks for no extension
     * @return true if the fileName is one of the extensions
     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes
     */
<span class="fc" id="L1249">    public static boolean isExtension(final String fileName, final String... extensions) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2124);</span>
<span class="pc bpc" id="L1250" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2125);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2126)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2127)==0&amp;false))) {{</span>
<span class="fc" id="L1251">            __CLR4_4_11a31a3kylvdytv.R.inc(2128);return false;</span>
        }
<span class="fc" id="L1253">        }__CLR4_4_11a31a3kylvdytv.R.inc(2129);requireNonNullChars(fileName);</span>

<span class="pc bpc" id="L1255" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2130);if ((((extensions == null || extensions.length == 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2131)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2132)==0&amp;false))) {{</span>
<span class="fc bfc" id="L1256" title="All 2 branches covered.">            __CLR4_4_11a31a3kylvdytv.R.inc(2133);return indexOfExtension(fileName) == NOT_FOUND;</span>
        }
<span class="fc" id="L1258">        }__CLR4_4_11a31a3kylvdytv.R.inc(2134);final String fileExt = getExtension(fileName);</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">        __CLR4_4_11a31a3kylvdytv.R.inc(2135);for (final String extension : extensions) {{</span>
<span class="pc bpc" id="L1260" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2136);if ((((fileExt.equals(extension))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2137)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2138)==0&amp;false))) {{</span>
<span class="fc" id="L1261">                __CLR4_4_11a31a3kylvdytv.R.inc(2139);return true;</span>
            }
        }}
<span class="fc" id="L1264">        }__CLR4_4_11a31a3kylvdytv.R.inc(2140);return false;</span>
<span class="fc" id="L1265">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether the extension of the fileName is one of those specified.
     * &lt;p&gt;
     * This method obtains the extension as the textual part of the fileName
     * after the last dot. There must be no directory separator after the dot.
     * The extension check is case-sensitive on all platforms.
     *
     * @param fileName  the fileName to query, null returns false
     * @param extensions  the extensions to check for, null checks for no extension
     * @return true if the fileName is one of the extensions
     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes
     */
<span class="fc" id="L1279">    public static boolean isExtension(final String fileName, final Collection&lt;String&gt; extensions) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2141);</span>
<span class="pc bpc" id="L1280" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2142);if ((((fileName == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2143)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2144)==0&amp;false))) {{</span>
<span class="fc" id="L1281">            __CLR4_4_11a31a3kylvdytv.R.inc(2145);return false;</span>
        }
<span class="fc" id="L1283">        }__CLR4_4_11a31a3kylvdytv.R.inc(2146);requireNonNullChars(fileName);</span>

<span class="pc bpc" id="L1285" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2147);if ((((extensions == null || extensions.isEmpty())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2148)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2149)==0&amp;false))) {{</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">            __CLR4_4_11a31a3kylvdytv.R.inc(2150);return indexOfExtension(fileName) == NOT_FOUND;</span>
        }
<span class="fc" id="L1288">        }__CLR4_4_11a31a3kylvdytv.R.inc(2151);final String fileExt = getExtension(fileName);</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        __CLR4_4_11a31a3kylvdytv.R.inc(2152);for (final String extension : extensions) {{</span>
<span class="pc bpc" id="L1290" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2153);if ((((fileExt.equals(extension))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2154)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2155)==0&amp;false))) {{</span>
<span class="fc" id="L1291">                __CLR4_4_11a31a3kylvdytv.R.inc(2156);return true;</span>
            }
        }}
<span class="fc" id="L1294">        }__CLR4_4_11a31a3kylvdytv.R.inc(2157);return false;</span>
<span class="fc" id="L1295">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks a fileName to see if it matches the specified wildcard matcher,
     * always testing case-sensitive.
     * &lt;p&gt;
     * The wildcard matcher uses the characters '?' and '*' to represent a
     * single or multiple (zero or more) wildcard characters.
     * This is the same as often found on Dos/Unix command lines.
     * The check is case-sensitive always.
     * &lt;pre&gt;
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.txt&quot;)      --&amp;gt; true
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.jpg&quot;)      --&amp;gt; false
     * wildcardMatch(&quot;a/b/c.txt&quot;, &quot;a/b/*&quot;)  --&amp;gt; true
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.???&quot;)      --&amp;gt; true
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.????&quot;)     --&amp;gt; false
     * &lt;/pre&gt;
     * N.B. the sequence &quot;*?&quot; does not work properly at present in match strings.
     *
     * @param fileName  the fileName to match on
     * @param wildcardMatcher  the wildcard string to match against
     * @return true if the fileName matches the wildcard string
     * @see IOCase#SENSITIVE
     */
<span class="fc" id="L1319">    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2158);</span>
<span class="fc" id="L1320">        __CLR4_4_11a31a3kylvdytv.R.inc(2159);return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);</span>
<span class="fc" id="L1321">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks a fileName to see if it matches the specified wildcard matcher
     * using the case rules of the system.
     * &lt;p&gt;
     * The wildcard matcher uses the characters '?' and '*' to represent a
     * single or multiple (zero or more) wildcard characters.
     * This is the same as often found on Dos/Unix command lines.
     * The check is case-sensitive on Unix and case-insensitive on Windows.
     * &lt;pre&gt;
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.txt&quot;)      --&amp;gt; true
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.jpg&quot;)      --&amp;gt; false
     * wildcardMatch(&quot;a/b/c.txt&quot;, &quot;a/b/*&quot;)  --&amp;gt; true
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.???&quot;)      --&amp;gt; true
     * wildcardMatch(&quot;c.txt&quot;, &quot;*.????&quot;)     --&amp;gt; false
     * &lt;/pre&gt;
     * N.B. the sequence &quot;*?&quot; does not work properly at present in match strings.
     *
     * @param fileName  the fileName to match on
     * @param wildcardMatcher  the wildcard string to match against
     * @return true if the fileName matches the wildcard string
     * @see IOCase#SYSTEM
     */
<span class="fc" id="L1345">    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2160);</span>
<span class="fc" id="L1346">        __CLR4_4_11a31a3kylvdytv.R.inc(2161);return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);</span>
<span class="fc" id="L1347">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks a fileName to see if it matches the specified wildcard matcher
     * allowing control over case-sensitivity.
     * &lt;p&gt;
     * The wildcard matcher uses the characters '?' and '*' to represent a
     * single or multiple (zero or more) wildcard characters.
     * N.B. the sequence &quot;*?&quot; does not work properly at present in match strings.
     *
     * @param fileName  the fileName to match on
     * @param wildcardMatcher  the wildcard string to match against
     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive
     * @return true if the fileName matches the wildcard string
     * @since 1.3
     */
<span class="fc" id="L1363">    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2162);</span>
<span class="pc bpc" id="L1364" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2163);if ((((fileName == null &amp;&amp; wildcardMatcher == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2164)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2165)==0&amp;false))) {{</span>
<span class="fc" id="L1365">            __CLR4_4_11a31a3kylvdytv.R.inc(2166);return true;</span>
        }
<span class="pc bpc" id="L1367" title="4 of 12 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2167);if ((((fileName == null || wildcardMatcher == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2168)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2169)==0&amp;false))) {{</span>
<span class="fc" id="L1368">            __CLR4_4_11a31a3kylvdytv.R.inc(2170);return false;</span>
        }
<span class="pc bpc" id="L1370" title="7 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2171);if ((((caseSensitivity == null)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2172)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2173)==0&amp;false))) {{</span>
<span class="nc" id="L1371">            __CLR4_4_11a31a3kylvdytv.R.inc(2174);caseSensitivity = IOCase.SENSITIVE;</span>
        }
<span class="fc" id="L1373">        }__CLR4_4_11a31a3kylvdytv.R.inc(2175);final String[] wcs = splitOnTokens(wildcardMatcher);</span>
<span class="fc" id="L1374">        __CLR4_4_11a31a3kylvdytv.R.inc(2176);boolean anyChars = false;</span>
<span class="fc" id="L1375">        __CLR4_4_11a31a3kylvdytv.R.inc(2177);int textIdx = 0;</span>
<span class="fc" id="L1376">        __CLR4_4_11a31a3kylvdytv.R.inc(2178);int wcsIdx = 0;</span>
<span class="fc" id="L1377">        __CLR4_4_11a31a3kylvdytv.R.inc(2179);final Deque&lt;int[]&gt; backtrack = new ArrayDeque&lt;&gt;(wcs.length);</span>

        // loop around a backtrack stack, to handle complex * matching
<span class="fc" id="L1380">        __CLR4_4_11a31a3kylvdytv.R.inc(2180);do {{</span>
<span class="pc bpc" id="L1381" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2181);if ((((!backtrack.isEmpty())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2182)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2183)==0&amp;false))) {{</span>
<span class="fc" id="L1382">                __CLR4_4_11a31a3kylvdytv.R.inc(2184);final int[] array = backtrack.pop();</span>
<span class="fc" id="L1383">                __CLR4_4_11a31a3kylvdytv.R.inc(2185);wcsIdx = array[0];</span>
<span class="fc" id="L1384">                __CLR4_4_11a31a3kylvdytv.R.inc(2186);textIdx = array[1];</span>
<span class="fc" id="L1385">                __CLR4_4_11a31a3kylvdytv.R.inc(2187);anyChars = true;</span>
            }

            // loop whilst tokens and text left to process
<span class="pc bpc" id="L1389" title="4 of 10 branches missed.">            }__CLR4_4_11a31a3kylvdytv.R.inc(2188);while ((((wcsIdx &lt; wcs.length)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2189)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2190)==0&amp;false))) {{</span>

<span class="pc bpc" id="L1391" title="4 of 10 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(2191);if ((((wcs[wcsIdx].equals(&quot;?&quot;))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2192)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2193)==0&amp;false))) {{</span>
                    // ? so move to next text char
<span class="fc" id="L1393">                    __CLR4_4_11a31a3kylvdytv.R.inc(2194);textIdx++;</span>
<span class="pc bpc" id="L1394" title="4 of 10 branches missed.">                    __CLR4_4_11a31a3kylvdytv.R.inc(2195);if ((((textIdx &gt; fileName.length())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2196)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2197)==0&amp;false))) {{</span>
<span class="fc" id="L1395">                        __CLR4_4_11a31a3kylvdytv.R.inc(2198);break;</span>
                    }
<span class="fc" id="L1397">                    }__CLR4_4_11a31a3kylvdytv.R.inc(2199);anyChars = false;</span>

<span class="pc bpc" id="L1399" title="4 of 10 branches missed.">                } }else {__CLR4_4_11a31a3kylvdytv.R.inc(2200);if ((((wcs[wcsIdx].equals(&quot;*&quot;))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2201)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2202)==0&amp;false))) {{</span>
                    // set any chars status
<span class="fc" id="L1401">                    __CLR4_4_11a31a3kylvdytv.R.inc(2203);anyChars = true;</span>
<span class="pc bpc" id="L1402" title="4 of 10 branches missed.">                    __CLR4_4_11a31a3kylvdytv.R.inc(2204);if ((((wcsIdx == wcs.length - 1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2205)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2206)==0&amp;false))) {{</span>
<span class="fc" id="L1403">                        __CLR4_4_11a31a3kylvdytv.R.inc(2207);textIdx = fileName.length();</span>
                    }

                }} }else {{
                    // matching text token
<span class="pc bpc" id="L1408" title="4 of 10 branches missed.">                    __CLR4_4_11a31a3kylvdytv.R.inc(2208);if ((((anyChars)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2209)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2210)==0&amp;false))) {{</span>
                        // any chars then try to locate text token
<span class="fc" id="L1410">                        __CLR4_4_11a31a3kylvdytv.R.inc(2211);textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);</span>
<span class="pc bpc" id="L1411" title="4 of 10 branches missed.">                        __CLR4_4_11a31a3kylvdytv.R.inc(2212);if ((((textIdx == NOT_FOUND)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2213)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2214)==0&amp;false))) {{</span>
                            // token not found
<span class="fc" id="L1413">                            __CLR4_4_11a31a3kylvdytv.R.inc(2215);break;</span>
                        }
<span class="fc" id="L1415">                        }__CLR4_4_11a31a3kylvdytv.R.inc(2216);final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);</span>
<span class="pc bpc" id="L1416" title="4 of 10 branches missed.">                        __CLR4_4_11a31a3kylvdytv.R.inc(2217);if ((((repeat &gt;= 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2218)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2219)==0&amp;false))) {{</span>
<span class="fc" id="L1417">                            __CLR4_4_11a31a3kylvdytv.R.inc(2220);backtrack.push(new int[] {wcsIdx, repeat});</span>
                        }
<span class="pc bpc" id="L1419" title="4 of 10 branches missed.">                    }} }else {__CLR4_4_11a31a3kylvdytv.R.inc(2221);if ((((!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx]))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2222)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2223)==0&amp;false))) {{</span>
                        // matching from current position
                        // couldn't match token
<span class="fc" id="L1422">                        __CLR4_4_11a31a3kylvdytv.R.inc(2224);break;</span>
                    }

                    // matched text token, move text index to end of matched token
<span class="fc" id="L1426">                    }}__CLR4_4_11a31a3kylvdytv.R.inc(2225);textIdx += wcs[wcsIdx].length();</span>
<span class="fc" id="L1427">                    __CLR4_4_11a31a3kylvdytv.R.inc(2226);anyChars = false;</span>
                }

<span class="fc" id="L1430">                }}__CLR4_4_11a31a3kylvdytv.R.inc(2227);wcsIdx++;</span>
            }

            // full match
<span class="pc bpc" id="L1434" title="4 of 12 branches missed.">            }__CLR4_4_11a31a3kylvdytv.R.inc(2228);if ((((wcsIdx == wcs.length &amp;&amp; textIdx == fileName.length())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2229)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2230)==0&amp;false))) {{</span>
<span class="fc" id="L1435">                __CLR4_4_11a31a3kylvdytv.R.inc(2231);return true;</span>
            }

<span class="pc bpc" id="L1438" title="4 of 10 branches missed.">        }} }while ((((!backtrack.isEmpty())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2232)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2233)==0&amp;false)));</span>

<span class="fc" id="L1440">        __CLR4_4_11a31a3kylvdytv.R.inc(2234);return false;</span>
<span class="fc" id="L1441">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Splits a string into a number of tokens.
     * The text is split by '?' and '*'.
     * Where multiple '*' occur consecutively they are collapsed into a single '*'.
     *
     * @param text  the text to split
     * @return the array of tokens, never null
     */
<span class="fc" id="L1451">    static String[] splitOnTokens(final String text) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2235);</span>
        // used by wildcardMatch
        // package level so a unit test may run on this

<span class="pc bpc" id="L1455" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2236);if ((((text.indexOf('?') == NOT_FOUND &amp;&amp; text.indexOf('*') == NOT_FOUND)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2237)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2238)==0&amp;false))) {{</span>
<span class="fc" id="L1456">            __CLR4_4_11a31a3kylvdytv.R.inc(2239);return new String[] { text };</span>
        }

<span class="fc" id="L1459">        }__CLR4_4_11a31a3kylvdytv.R.inc(2240);final char[] array = text.toCharArray();</span>
<span class="fc" id="L1460">        __CLR4_4_11a31a3kylvdytv.R.inc(2241);final ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1461">        __CLR4_4_11a31a3kylvdytv.R.inc(2242);final StringBuilder buffer = new StringBuilder();</span>
<span class="fc" id="L1462">        __CLR4_4_11a31a3kylvdytv.R.inc(2243);char prevChar = 0;</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">        __CLR4_4_11a31a3kylvdytv.R.inc(2244);for (final char ch : array) {{</span>
<span class="pc bpc" id="L1464" title="4 of 12 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2245);if ((((ch == '?' || ch == '*')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2246)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2247)==0&amp;false))) {{</span>
<span class="pc bpc" id="L1465" title="4 of 10 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(2248);if ((((buffer.length() != 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2249)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2250)==0&amp;false))) {{</span>
<span class="fc" id="L1466">                    __CLR4_4_11a31a3kylvdytv.R.inc(2251);list.add(buffer.toString());</span>
<span class="fc" id="L1467">                    __CLR4_4_11a31a3kylvdytv.R.inc(2252);buffer.setLength(0);</span>
                }
<span class="pc bpc" id="L1469" title="4 of 10 branches missed.">                }__CLR4_4_11a31a3kylvdytv.R.inc(2253);if ((((ch == '?')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2254)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2255)==0&amp;false))) {{</span>
<span class="fc" id="L1470">                    __CLR4_4_11a31a3kylvdytv.R.inc(2256);list.add(&quot;?&quot;);</span>
<span class="pc bpc" id="L1471" title="4 of 10 branches missed.">                } }else {__CLR4_4_11a31a3kylvdytv.R.inc(2257);if ((((prevChar != '*')&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2258)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2259)==0&amp;false))) {{// ch == '*' here; check if previous char was '*'</span>
<span class="fc" id="L1472">                    __CLR4_4_11a31a3kylvdytv.R.inc(2260);list.add(&quot;*&quot;);</span>
                }
            }}} }else {{
<span class="fc" id="L1475">                __CLR4_4_11a31a3kylvdytv.R.inc(2261);buffer.append(ch);</span>
            }
<span class="fc" id="L1477">            }__CLR4_4_11a31a3kylvdytv.R.inc(2262);prevChar = ch;</span>
        }
<span class="pc bpc" id="L1479" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2263);if ((((buffer.length() != 0)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2264)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2265)==0&amp;false))) {{</span>
<span class="fc" id="L1480">            __CLR4_4_11a31a3kylvdytv.R.inc(2266);list.add(buffer.toString());</span>
        }

<span class="fc" id="L1483">        }__CLR4_4_11a31a3kylvdytv.R.inc(2267);return list.toArray(EMPTY_STRING_ARRAY);</span>
<span class="fc" id="L1484">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    /**
     * Checks whether a given string is a valid host name according to
     * RFC 3986.
     *
     * &lt;p&gt;Accepted are IP addresses (v4 and v6) as well as what the
     * RFC calls a &quot;reg-name&quot;. Percent encoded names don't seem to be
     * valid names in UNC paths.&lt;/p&gt;
     *
     * @see &quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;
     * @param name the hostname to validate
     * @return true if the given name is a valid host name
     */
<span class="fc" id="L1498">    private static boolean isValidHostName(final String name) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2268);</span>
<span class="fc bfc" id="L1499" title="All 4 branches covered.">        __CLR4_4_11a31a3kylvdytv.R.inc(2269);return isIPv6Address(name) || isRFC3986HostName(name);</span>
<span class="fc" id="L1500">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

<span class="fc" id="L1502">    private static final Pattern IPV4_PATTERN =</span>
<span class="fc" id="L1503">        Pattern.compile(&quot;^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$&quot;);</span>
    private static final int IPV4_MAX_OCTET_VALUE = 255;

    /**
     * Checks whether a given string represents a valid IPv4 address.
     *
     * @param name the name to validate
     * @return true if the given name is a valid IPv4 address
     */
    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address
<span class="fc" id="L1513">    private static boolean isIPv4Address(final String name) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2270);</span>
<span class="fc" id="L1514">        __CLR4_4_11a31a3kylvdytv.R.inc(2271);final Matcher m = IPV4_PATTERN.matcher(name);</span>
<span class="pc bpc" id="L1515" title="5 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2272);if ((((!m.matches() || m.groupCount() != 4)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2273)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2274)==0&amp;false))) {{</span>
<span class="fc" id="L1516">            __CLR4_4_11a31a3kylvdytv.R.inc(2275);return false;</span>
        }

        // verify that address subgroups are legal
<span class="pc bpc" id="L1520" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2276);for (int i = 1; (((i &lt;= 4)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2277)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2278)==0&amp;false)); i++) {{</span>
<span class="fc" id="L1521">            __CLR4_4_11a31a3kylvdytv.R.inc(2279);final String ipSegment = m.group(i);</span>
<span class="fc" id="L1522">            __CLR4_4_11a31a3kylvdytv.R.inc(2280);final int iIpSegment = Integer.parseInt(ipSegment);</span>
<span class="pc bpc" id="L1523" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2281);if ((((iIpSegment &gt; IPV4_MAX_OCTET_VALUE)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2282)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2283)==0&amp;false))) {{</span>
<span class="fc" id="L1524">                __CLR4_4_11a31a3kylvdytv.R.inc(2284);return false;</span>
            }

<span class="pc bpc" id="L1527" title="4 of 12 branches missed.">            }__CLR4_4_11a31a3kylvdytv.R.inc(2285);if ((((ipSegment.length() &gt; 1 &amp;&amp; ipSegment.startsWith(&quot;0&quot;))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2286)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2287)==0&amp;false))) {{</span>
<span class="fc" id="L1528">                __CLR4_4_11a31a3kylvdytv.R.inc(2288);return false;</span>
            }

        }}

<span class="fc" id="L1533">        }__CLR4_4_11a31a3kylvdytv.R.inc(2289);return true;</span>
<span class="fc" id="L1534">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

    private static final int IPV6_MAX_HEX_GROUPS = 8;
    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;
    private static final int MAX_UNSIGNED_SHORT = 0xffff;
    private static final int BASE_16 = 16;

    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address
    /**
     * Checks whether a given string represents a valid IPv6 address.
     *
     * @param inet6Address the name to validate
     * @return true if the given name is a valid IPv6 address
     */
<span class="fc" id="L1548">    private static boolean isIPv6Address(final String inet6Address) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2290);</span>
<span class="fc" id="L1549">        __CLR4_4_11a31a3kylvdytv.R.inc(2291);final boolean containsCompressedZeroes = inet6Address.contains(&quot;::&quot;);</span>
<span class="pc bpc" id="L1550" title="4 of 12 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2292);if ((((containsCompressedZeroes &amp;&amp; (inet6Address.indexOf(&quot;::&quot;) != inet6Address.lastIndexOf(&quot;::&quot;)))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2293)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2294)==0&amp;false))) {{</span>
<span class="fc" id="L1551">            __CLR4_4_11a31a3kylvdytv.R.inc(2295);return false;</span>
        }
<span class="fc bfc" id="L1553" title="All 4 branches covered.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2296);if (((((inet6Address.startsWith(&quot;:&quot;) &amp;&amp; !inet6Address.startsWith(&quot;::&quot;))</span>
<span class="pc bpc" id="L1554" title="4 of 12 branches missed.">                || (inet6Address.endsWith(&quot;:&quot;) &amp;&amp; !inet6Address.endsWith(&quot;::&quot;)))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2297)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2298)==0&amp;false))) {{</span>
<span class="fc" id="L1555">            __CLR4_4_11a31a3kylvdytv.R.inc(2299);return false;</span>
        }
<span class="fc" id="L1557">        }__CLR4_4_11a31a3kylvdytv.R.inc(2300);String[] octets = inet6Address.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L1558" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2301);if ((((containsCompressedZeroes)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2302)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2303)==0&amp;false))) {{</span>
<span class="fc" id="L1559">            __CLR4_4_11a31a3kylvdytv.R.inc(2304);final List&lt;String&gt; octetList = new ArrayList&lt;&gt;(Arrays.asList(octets));</span>
<span class="pc bpc" id="L1560" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2305);if ((((inet6Address.endsWith(&quot;::&quot;))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2306)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2307)==0&amp;false))) {{</span>
                // String.split() drops ending empty segments
<span class="fc" id="L1562">                __CLR4_4_11a31a3kylvdytv.R.inc(2308);octetList.add(&quot;&quot;);</span>
<span class="pc bpc" id="L1563" title="5 of 12 branches missed.">            } }else {__CLR4_4_11a31a3kylvdytv.R.inc(2309);if ((((inet6Address.startsWith(&quot;::&quot;) &amp;&amp; !octetList.isEmpty())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2310)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2311)==0&amp;false))) {{</span>
<span class="fc" id="L1564">                __CLR4_4_11a31a3kylvdytv.R.inc(2312);octetList.remove(0);</span>
            }
<span class="fc" id="L1566">            }}__CLR4_4_11a31a3kylvdytv.R.inc(2313);octets = octetList.toArray(EMPTY_STRING_ARRAY);</span>
        }
<span class="pc bpc" id="L1568" title="4 of 10 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2314);if ((((octets.length &gt; IPV6_MAX_HEX_GROUPS)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2315)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2316)==0&amp;false))) {{</span>
<span class="fc" id="L1569">            __CLR4_4_11a31a3kylvdytv.R.inc(2317);return false;</span>
        }
<span class="fc" id="L1571">        }__CLR4_4_11a31a3kylvdytv.R.inc(2318);int validOctets = 0;</span>
<span class="fc" id="L1572">        __CLR4_4_11a31a3kylvdytv.R.inc(2319);int emptyOctets = 0; // consecutive empty chunks</span>
<span class="pc bpc" id="L1573" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2320);for (int index = 0; (((index &lt; octets.length)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2321)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2322)==0&amp;false)); index++) {{</span>
<span class="fc" id="L1574">            __CLR4_4_11a31a3kylvdytv.R.inc(2323);final String octet = octets[index];</span>
<span class="pc bpc" id="L1575" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2324);if ((((octet.isEmpty())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2325)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2326)==0&amp;false))) {{</span>
<span class="fc" id="L1576">                __CLR4_4_11a31a3kylvdytv.R.inc(2327);emptyOctets++;</span>
<span class="pc bpc" id="L1577" title="7 of 10 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(2328);if ((((emptyOctets &gt; 1)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2329)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2330)==0&amp;false))) {{</span>
<span class="nc" id="L1578">                    __CLR4_4_11a31a3kylvdytv.R.inc(2331);return false;</span>
                }
            }} }else {{
<span class="fc" id="L1581">                __CLR4_4_11a31a3kylvdytv.R.inc(2332);emptyOctets = 0;</span>
                // Is last chunk an IPv4 address?
<span class="pc bpc" id="L1583" title="4 of 12 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(2333);if ((((index == octets.length - 1 &amp;&amp; octet.contains(&quot;.&quot;))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2334)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2335)==0&amp;false))) {{</span>
<span class="pc bpc" id="L1584" title="4 of 10 branches missed.">                    __CLR4_4_11a31a3kylvdytv.R.inc(2336);if ((((!isIPv4Address(octet))&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2337)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2338)==0&amp;false))) {{</span>
<span class="fc" id="L1585">                        __CLR4_4_11a31a3kylvdytv.R.inc(2339);return false;</span>
                    }
<span class="fc" id="L1587">                    }__CLR4_4_11a31a3kylvdytv.R.inc(2340);validOctets += 2;</span>
<span class="fc" id="L1588">                    __CLR4_4_11a31a3kylvdytv.R.inc(2341);continue;</span>
                }
<span class="pc bpc" id="L1590" title="4 of 10 branches missed.">                }__CLR4_4_11a31a3kylvdytv.R.inc(2342);if ((((octet.length() &gt; IPV6_MAX_HEX_DIGITS_PER_GROUP)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2343)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2344)==0&amp;false))) {{</span>
<span class="fc" id="L1591">                    __CLR4_4_11a31a3kylvdytv.R.inc(2345);return false;</span>
                }
<span class="fc" id="L1593">                }__CLR4_4_11a31a3kylvdytv.R.inc(2346);final int octetInt;</span>
<span class="fc" id="L1594">                __CLR4_4_11a31a3kylvdytv.R.inc(2347);try {</span>
<span class="fc" id="L1595">                    __CLR4_4_11a31a3kylvdytv.R.inc(2348);octetInt = Integer.parseInt(octet, BASE_16);</span>
<span class="fc" id="L1596">                } catch (final NumberFormatException e) {</span>
<span class="fc" id="L1597">                    __CLR4_4_11a31a3kylvdytv.R.inc(2349);return false;</span>
<span class="fc" id="L1598">                }</span>
<span class="pc bpc" id="L1599" title="8 of 12 branches missed.">                __CLR4_4_11a31a3kylvdytv.R.inc(2350);if ((((octetInt &lt; 0 || octetInt &gt; MAX_UNSIGNED_SHORT)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2351)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2352)==0&amp;false))) {{</span>
<span class="nc" id="L1600">                    __CLR4_4_11a31a3kylvdytv.R.inc(2353);return false;</span>
                }
            }}
<span class="fc" id="L1603">            }__CLR4_4_11a31a3kylvdytv.R.inc(2354);validOctets++;</span>
        }
<span class="pc bpc" id="L1605" title="2 of 6 branches missed.">        }__CLR4_4_11a31a3kylvdytv.R.inc(2355);return validOctets &lt;= IPV6_MAX_HEX_GROUPS &amp;&amp; (validOctets &gt;= IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);</span>
<span class="fc" id="L1606">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>

<span class="fc" id="L1608">    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9][a-zA-Z0-9-]*$&quot;);</span>

    /**
     * Checks whether a given string is a valid host name according to
     * RFC 3986 - not accepting IP addresses.
     *
     * @see &quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;
     * @param name the hostname to validate
     * @return true if the given name is a valid host name
     */
<span class="fc" id="L1618">    private static boolean isRFC3986HostName(final String name) {try{__CLR4_4_11a31a3kylvdytv.R.inc(2356);</span>
<span class="fc" id="L1619">        __CLR4_4_11a31a3kylvdytv.R.inc(2357);final String[] parts = name.split(&quot;\\.&quot;, -1);</span>
<span class="pc bpc" id="L1620" title="4 of 10 branches missed.">        __CLR4_4_11a31a3kylvdytv.R.inc(2358);for (int i = 0; (((i &lt; parts.length)&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2359)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2360)==0&amp;false)); i++) {{</span>
<span class="pc bpc" id="L1621" title="4 of 10 branches missed.">            __CLR4_4_11a31a3kylvdytv.R.inc(2361);if ((((parts[i].isEmpty())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2362)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2363)==0&amp;false))) {{</span>
                // trailing dot is legal, otherwise we've hit a .. sequence
<span class="fc bfc" id="L1623" title="All 2 branches covered.">                __CLR4_4_11a31a3kylvdytv.R.inc(2364);return i == parts.length - 1;</span>
            }
<span class="pc bpc" id="L1625" title="4 of 10 branches missed.">            }__CLR4_4_11a31a3kylvdytv.R.inc(2365);if ((((!REG_NAME_PART_PATTERN.matcher(parts[i]).matches())&amp;&amp;(__CLR4_4_11a31a3kylvdytv.R.iget(2366)!=0|true))||(__CLR4_4_11a31a3kylvdytv.R.iget(2367)==0&amp;false))) {{</span>
<span class="fc" id="L1626">                __CLR4_4_11a31a3kylvdytv.R.inc(2368);return false;</span>
            }
        }}
<span class="fc" id="L1629">        }__CLR4_4_11a31a3kylvdytv.R.inc(2369);return true;</span>
<span class="fc" id="L1630">    }finally{__CLR4_4_11a31a3kylvdytv.R.flushNeeded();}}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>
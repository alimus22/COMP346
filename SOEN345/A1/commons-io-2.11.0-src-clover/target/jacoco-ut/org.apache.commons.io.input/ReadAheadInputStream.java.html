<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReadAheadInputStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons IO</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.io.input</a> &gt; <span class="el_source">ReadAheadInputStream.java</span></div><h1>ReadAheadInputStream.java</h1><pre class="source lang-java linenums">/* $$ This file has been instrumented by Clover 4.4.1#2019101123313948 $$ *//*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.io.input;

import static org.apache.commons.io.IOUtils.EOF;

// import javax.annotation.concurrent.GuardedBy;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.nio.ByteBuffer;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Implements {@link InputStream} to asynchronously read ahead from an underlying input stream when a specified amount
 * of data has been read from the current buffer. It does so by maintaining two buffers: an active buffer and a read
 * ahead buffer. The active buffer contains data which should be returned when a read() call is issued. The read ahead
 * buffer is used to asynchronously read from the underlying input stream. When the current active buffer is exhausted,
 * we flip the two buffers so that we can start reading from the read ahead buffer without being blocked by disk I/O.
 * &lt;p&gt;
 * This class was ported and adapted from Apache Spark commit 933dc6cb7b3de1d8ccaf73d124d6eb95b947ed19.
 * &lt;/p&gt;
 *
 * @since 2.9.0
 */
<span class="pc bpc" id="L44" title="4 of 6 branches missed.">public class ReadAheadInputStream extends InputStream {public static class __CLR4_4_1531531kylvdzxb{public static com_atlassian_clover.CoverageRecorder R;public static com_atlassian_clover.CloverProfile[] profiles = { };@java.lang.SuppressWarnings(&quot;unchecked&quot;) public static &lt;I, T extends I&gt; I lambdaInc(final int i,final T l,final int si){java.lang.reflect.InvocationHandler h=new java.lang.reflect.InvocationHandler(){public java.lang.Object invoke(java.lang.Object p,java.lang.reflect.Method m,java.lang.Object[] a) throws Throwable{R.inc(i);R.inc(si);try{return m.invoke(l,a);}catch(java.lang.reflect.InvocationTargetException e){throw e.getCause()!=null?e.getCause():new RuntimeException(&quot;Clover failed to invoke instrumented lambda&quot;,e);}}};return (I)java.lang.reflect.Proxy.newProxyInstance(l.getClass().getClassLoader(),l.getClass().getInterfaces(),h);}static{com_atlassian_clover.CoverageRecorder _R=null;try{com_atlassian_clover.CloverVersionInfo.An_old_version_of_clover_is_on_your_compilation_classpath___Please_remove___Required_version_is___4_4_1();if(2019101123313948L!=com_atlassian_clover.CloverVersionInfo.getBuildStamp()){com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: The Clover version used in instrumentation does not match the runtime version. You need to run instrumented classes against the same version of Clover that you instrumented with.&quot;);com_atlassian_clover.Clover.l(&quot;[CLOVER] WARNING: Instr=4.4.1#2019101123313948,Runtime=&quot;+com_atlassian_clover.CloverVersionInfo.getReleaseNum()+&quot;#&quot;+com_atlassian_clover.CloverVersionInfo.getBuildStamp());}R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getNullRecorder();_R=com_atlassian_clover.Clover.getRecorder(&quot;\u002f\u0055\u0073\u0065\u0072\u0073\u002f\u0061\u006c\u0069\u0068\u0061\u006e\u006e\u0069\u002f\u0044\u0065\u0073\u006b\u0074\u006f\u0070\u002f\u0047\u0069\u0074\u0048\u0075\u0062\u002f\u0053\u004f\u0045\u004e\u002f\u0053\u004f\u0045\u004e\u0033\u0034\u0035\u002f\u0041\u0031\u002f\u0063\u006f\u006d\u006d\u006f\u006e\u0073\u002d\u0069\u006f\u002d\u0032\u002e\u0031\u0031\u002e\u0030\u002d\u0073\u0072\u0063\u002f\u0074\u0061\u0072\u0067\u0065\u0074\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002f\u0063\u006c\u006f\u0076\u0065\u0072\u002e\u0064\u0062&quot;,1642616389890L,8589935092L,6837,profiles,new java.lang.String[]{&quot;clover.distributed.coverage&quot;,null});}catch(java.lang.SecurityException e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because it has insufficient security privileges. Please consult the Clover documentation on the security policy file changes required. (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.NoClassDefFoundError e){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised. Are you sure you have Clover in the runtime classpath? (&quot;+e.getClass()+&quot;:&quot;+e.getMessage()+&quot;)&quot;);}catch(java.lang.Throwable t){java.lang.System.err.println(&quot;[CLOVER] FATAL ERROR: Clover could not be initialised because of an unexpected error. (&quot;+t.getClass()+&quot;:&quot;+t.getMessage()+&quot;)&quot;);}R=_R;}}public static final com_atlassian_clover.TestNameSniffer __CLR4_4_1_TEST_NAME_SNIFFER=com_atlassian_clover.TestNameSniffer.NULL_INSTANCE;</span>

<span class="fc" id="L46">    private static final ThreadLocal&lt;byte[]&gt; oneByte = ThreadLocal.withInitial(() -&gt; new byte[1]);</span>

    /**
     * Creates a new daemon executor service.
     *
     * @return a new daemon executor service.
     */
<span class="fc" id="L53">    private static ExecutorService newExecutorService() {try{__CLR4_4_1531531kylvdzxb.R.inc(6589);</span>
<span class="fc" id="L54">        __CLR4_4_1531531kylvdzxb.R.inc(6590);return Executors.newSingleThreadExecutor(ReadAheadInputStream::newThread);</span>
<span class="fc" id="L55">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    /**
     * Creates a new daemon thread.
     *
     * @param r the thread's runnable.
     * @return a new daemon thread.
     */
<span class="fc" id="L63">    private static Thread newThread(final Runnable r) {try{__CLR4_4_1531531kylvdzxb.R.inc(6591);</span>
<span class="fc" id="L64">        __CLR4_4_1531531kylvdzxb.R.inc(6592);final Thread thread = new Thread(r, &quot;commons-io-read-ahead&quot;);</span>
<span class="fc" id="L65">        __CLR4_4_1531531kylvdzxb.R.inc(6593);thread.setDaemon(true);</span>
<span class="fc" id="L66">        __CLR4_4_1531531kylvdzxb.R.inc(6594);return thread;</span>
<span class="fc" id="L67">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

<span class="fc" id="L69">    private final ReentrantLock stateChangeLock = new ReentrantLock();</span>

    // @GuardedBy(&quot;stateChangeLock&quot;)
    private ByteBuffer activeBuffer;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    private ByteBuffer readAheadBuffer;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    private boolean endOfStream;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    // true if async read is in progress
    private boolean readInProgress;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    // true if read is aborted due to an exception in reading from underlying input stream.
    private boolean readAborted;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    private Throwable readException;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    // whether the close method is called.
    private boolean isClosed;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    // true when the close method will close the underlying input stream. This is valid only if
    // `isClosed` is true.
    private boolean isUnderlyingInputStreamBeingClosed;

    // @GuardedBy(&quot;stateChangeLock&quot;)
    // whether there is a read ahead task running,
    private boolean isReading;

    // Whether there is a reader waiting for data.
<span class="fc" id="L105">    private final AtomicBoolean isWaiting = new AtomicBoolean(false);</span>

    private final InputStream underlyingInputStream;

    private final ExecutorService executorService;

    private final boolean shutdownExecutorService;

<span class="fc" id="L113">    private final Condition asyncReadComplete = stateChangeLock.newCondition();</span>

    /**
     * Creates an instance with the specified buffer size and read-ahead threshold
     *
     * @param inputStream The underlying input stream.
     * @param bufferSizeInBytes The buffer size.
     */
    public ReadAheadInputStream(final InputStream inputStream, final int bufferSizeInBytes) {
<span class="fc" id="L122">        this(inputStream, bufferSizeInBytes, newExecutorService(), true);__CLR4_4_1531531kylvdzxb.R.inc(6596);try{__CLR4_4_1531531kylvdzxb.R.inc(6595);</span>
<span class="fc" id="L123">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    /**
     * Creates an instance with the specified buffer size and read-ahead threshold
     *
     * @param inputStream The underlying input stream.
     * @param bufferSizeInBytes The buffer size.
     * @param executorService An executor service for the read-ahead thread.
     */
    public ReadAheadInputStream(final InputStream inputStream, final int bufferSizeInBytes,
        final ExecutorService executorService) {
<span class="nc" id="L134">        this(inputStream, bufferSizeInBytes, executorService, false);__CLR4_4_1531531kylvdzxb.R.inc(6598);try{__CLR4_4_1531531kylvdzxb.R.inc(6597);</span>
<span class="nc" id="L135">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    /**
     * Creates an instance with the specified buffer size and read-ahead threshold
     *
     * @param inputStream The underlying input stream.
     * @param bufferSizeInBytes The buffer size.
     * @param executorService An executor service for the read-ahead thread.
     * @param shutdownExecutorService Whether or not to shutdown the given ExecutorService on close.
     */
    private ReadAheadInputStream(final InputStream inputStream, final int bufferSizeInBytes,
<span class="fc" id="L146">        final ExecutorService executorService, final boolean shutdownExecutorService) {try{__CLR4_4_1531531kylvdzxb.R.inc(6599);</span>
<span class="pc bpc" id="L147" title="7 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6600);if ((((bufferSizeInBytes &lt;= 0)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6601)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6602)==0&amp;false))) {{</span>
<span class="nc" id="L148">            __CLR4_4_1531531kylvdzxb.R.inc(6603);throw new IllegalArgumentException(</span>
                &quot;bufferSizeInBytes should be greater than 0, but the value is &quot; + bufferSizeInBytes);
        }
<span class="fc" id="L151">        }__CLR4_4_1531531kylvdzxb.R.inc(6604);this.executorService = Objects.requireNonNull(executorService, &quot;executorService&quot;);</span>
<span class="fc" id="L152">        __CLR4_4_1531531kylvdzxb.R.inc(6605);this.underlyingInputStream = Objects.requireNonNull(inputStream, &quot;inputStream&quot;);</span>
<span class="fc" id="L153">        __CLR4_4_1531531kylvdzxb.R.inc(6606);this.shutdownExecutorService = shutdownExecutorService;</span>
<span class="fc" id="L154">        __CLR4_4_1531531kylvdzxb.R.inc(6607);this.activeBuffer = ByteBuffer.allocate(bufferSizeInBytes);</span>
<span class="fc" id="L155">        __CLR4_4_1531531kylvdzxb.R.inc(6608);this.readAheadBuffer = ByteBuffer.allocate(bufferSizeInBytes);</span>
<span class="fc" id="L156">        __CLR4_4_1531531kylvdzxb.R.inc(6609);this.activeBuffer.flip();</span>
<span class="fc" id="L157">        __CLR4_4_1531531kylvdzxb.R.inc(6610);this.readAheadBuffer.flip();</span>
<span class="fc" id="L158">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    @Override
<span class="fc" id="L161">    public int available() throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6611);</span>
<span class="fc" id="L162">        __CLR4_4_1531531kylvdzxb.R.inc(6612);stateChangeLock.lock();</span>
        // Make sure we have no integer overflow.
<span class="fc" id="L164">        __CLR4_4_1531531kylvdzxb.R.inc(6613);try {</span>
<span class="fc" id="L165">            __CLR4_4_1531531kylvdzxb.R.inc(6614);return (int) Math.min(Integer.MAX_VALUE, (long) activeBuffer.remaining() + readAheadBuffer.remaining());</span>
        } finally {
<span class="fc" id="L167">            __CLR4_4_1531531kylvdzxb.R.inc(6615);stateChangeLock.unlock();</span>
        }
<span class="fc" id="L169">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

<span class="fc" id="L171">    private void checkReadException() throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6616);</span>
<span class="pc bpc" id="L172" title="7 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6617);if ((((readAborted)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6618)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6619)==0&amp;false))) {{</span>
<span class="nc bnc" id="L173" title="All 10 branches missed.">            __CLR4_4_1531531kylvdzxb.R.inc(6620);if ((((readException instanceof IOException)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6621)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6622)==0&amp;false))) {{</span>
<span class="nc" id="L174">                __CLR4_4_1531531kylvdzxb.R.inc(6623);throw (IOException) readException;</span>
            }
<span class="nc" id="L176">            }__CLR4_4_1531531kylvdzxb.R.inc(6624);throw new IOException(readException);</span>
        }
<span class="fc" id="L178">    }}finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    @Override
<span class="fc" id="L181">    public void close() throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6625);</span>
<span class="fc" id="L182">        __CLR4_4_1531531kylvdzxb.R.inc(6626);boolean isSafeToCloseUnderlyingInputStream = false;</span>
<span class="fc" id="L183">        __CLR4_4_1531531kylvdzxb.R.inc(6627);stateChangeLock.lock();</span>
<span class="fc" id="L184">        __CLR4_4_1531531kylvdzxb.R.inc(6628);try {</span>
<span class="pc bpc" id="L185" title="7 of 10 branches missed.">            __CLR4_4_1531531kylvdzxb.R.inc(6629);if ((((isClosed)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6630)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6631)==0&amp;false))) {{</span>
<span class="nc" id="L186">                __CLR4_4_1531531kylvdzxb.R.inc(6632);return;</span>
            }
<span class="fc" id="L188">            }__CLR4_4_1531531kylvdzxb.R.inc(6633);isClosed = true;</span>
<span class="pc bpc" id="L189" title="7 of 10 branches missed.">            __CLR4_4_1531531kylvdzxb.R.inc(6634);if ((((!isReading)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6635)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6636)==0&amp;false))) {{</span>
                // Nobody is reading, so we can close the underlying input stream in this method.
<span class="fc" id="L191">                __CLR4_4_1531531kylvdzxb.R.inc(6637);isSafeToCloseUnderlyingInputStream = true;</span>
                // Flip this to make sure the read ahead task will not close the underlying input stream.
<span class="fc" id="L193">                __CLR4_4_1531531kylvdzxb.R.inc(6638);isUnderlyingInputStreamBeingClosed = true;</span>
            }
        }} finally {
<span class="fc" id="L196">            __CLR4_4_1531531kylvdzxb.R.inc(6639);stateChangeLock.unlock();</span>
        }

<span class="pc bpc" id="L199" title="7 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6640);if ((((shutdownExecutorService)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6641)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6642)==0&amp;false))) {{</span>
<span class="fc" id="L200">            __CLR4_4_1531531kylvdzxb.R.inc(6643);try {</span>
<span class="fc" id="L201">                __CLR4_4_1531531kylvdzxb.R.inc(6644);executorService.shutdownNow();</span>
<span class="fc" id="L202">                __CLR4_4_1531531kylvdzxb.R.inc(6645);executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L203">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L204">                __CLR4_4_1531531kylvdzxb.R.inc(6646);final InterruptedIOException iio = new InterruptedIOException(e.getMessage());</span>
<span class="nc" id="L205">                __CLR4_4_1531531kylvdzxb.R.inc(6647);iio.initCause(e);</span>
<span class="nc" id="L206">                __CLR4_4_1531531kylvdzxb.R.inc(6648);throw iio;</span>
            } finally {
<span class="pc bpc" id="L208" title="7 of 10 branches missed.">                __CLR4_4_1531531kylvdzxb.R.inc(6649);if ((((isSafeToCloseUnderlyingInputStream)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6650)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6651)==0&amp;false))) {{</span>
<span class="fc" id="L209">                    __CLR4_4_1531531kylvdzxb.R.inc(6652);underlyingInputStream.close();</span>
                }
            }}
        }
<span class="fc" id="L213">    }}finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

<span class="fc" id="L215">    private void closeUnderlyingInputStreamIfNecessary() {try{__CLR4_4_1531531kylvdzxb.R.inc(6653);</span>
<span class="fc" id="L216">        __CLR4_4_1531531kylvdzxb.R.inc(6654);boolean needToCloseUnderlyingInputStream = false;</span>
<span class="fc" id="L217">        __CLR4_4_1531531kylvdzxb.R.inc(6655);stateChangeLock.lock();</span>
<span class="fc" id="L218">        __CLR4_4_1531531kylvdzxb.R.inc(6656);try {</span>
<span class="fc" id="L219">            __CLR4_4_1531531kylvdzxb.R.inc(6657);isReading = false;</span>
<span class="pc bpc" id="L220" title="9 of 12 branches missed.">            __CLR4_4_1531531kylvdzxb.R.inc(6658);if ((((isClosed &amp;&amp; !isUnderlyingInputStreamBeingClosed)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6659)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6660)==0&amp;false))) {{</span>
                // close method cannot close underlyingInputStream because we were reading.
<span class="nc" id="L222">                __CLR4_4_1531531kylvdzxb.R.inc(6661);needToCloseUnderlyingInputStream = true;</span>
            }
        }} finally {
<span class="fc" id="L225">            __CLR4_4_1531531kylvdzxb.R.inc(6662);stateChangeLock.unlock();</span>
        }
<span class="pc bpc" id="L227" title="7 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6663);if ((((needToCloseUnderlyingInputStream)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6664)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6665)==0&amp;false))) {{</span>
<span class="nc" id="L228">            __CLR4_4_1531531kylvdzxb.R.inc(6666);try {</span>
<span class="nc" id="L229">                __CLR4_4_1531531kylvdzxb.R.inc(6667);underlyingInputStream.close();</span>
<span class="nc" id="L230">            } catch (final IOException e) {</span>
                // TODO ?
<span class="nc" id="L232">            }</span>
        }
<span class="fc" id="L234">    }}finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

<span class="fc" id="L236">    private boolean isEndOfStream() {try{__CLR4_4_1531531kylvdzxb.R.inc(6668);</span>
<span class="fc bfc" id="L237" title="All 6 branches covered.">        __CLR4_4_1531531kylvdzxb.R.inc(6669);return !activeBuffer.hasRemaining() &amp;&amp; !readAheadBuffer.hasRemaining() &amp;&amp; endOfStream;</span>
<span class="fc" id="L238">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    @Override
<span class="fc" id="L241">    public int read() throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6670);</span>
<span class="pc bpc" id="L242" title="4 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6671);if ((((activeBuffer.hasRemaining())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6672)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6673)==0&amp;false))) {{</span>
            // short path - just get one byte.
<span class="fc" id="L244">            __CLR4_4_1531531kylvdzxb.R.inc(6674);return activeBuffer.get() &amp; 0xFF;</span>
        }
<span class="fc" id="L246">        }__CLR4_4_1531531kylvdzxb.R.inc(6675);final byte[] oneByteArray = oneByte.get();</span>
<span class="pc bpc" id="L247" title="4 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6676);return (((read(oneByteArray, 0, 1) == EOF )&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6677)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6678)==0&amp;false))? -1 : oneByteArray[0] &amp; 0xFF;</span>
<span class="fc" id="L248">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    @Override
<span class="fc" id="L251">    public int read(final byte[] b, final int offset, int len) throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6679);</span>
<span class="pc bpc" id="L252" title="9 of 14 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6680);if ((((offset &lt; 0 || len &lt; 0 || len &gt; b.length - offset)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6681)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6682)==0&amp;false))) {{</span>
<span class="nc" id="L253">            __CLR4_4_1531531kylvdzxb.R.inc(6683);throw new IndexOutOfBoundsException();</span>
        }
<span class="pc bpc" id="L255" title="7 of 10 branches missed.">        }__CLR4_4_1531531kylvdzxb.R.inc(6684);if ((((len == 0)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6685)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6686)==0&amp;false))) {{</span>
<span class="nc" id="L256">            __CLR4_4_1531531kylvdzxb.R.inc(6687);return 0;</span>
        }

<span class="pc bpc" id="L259" title="4 of 10 branches missed.">        }__CLR4_4_1531531kylvdzxb.R.inc(6688);if ((((!activeBuffer.hasRemaining())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6689)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6690)==0&amp;false))) {{</span>
            // No remaining in active buffer - lock and switch to write ahead buffer.
<span class="fc" id="L261">            __CLR4_4_1531531kylvdzxb.R.inc(6691);stateChangeLock.lock();</span>
<span class="fc" id="L262">            __CLR4_4_1531531kylvdzxb.R.inc(6692);try {</span>
<span class="fc" id="L263">                __CLR4_4_1531531kylvdzxb.R.inc(6693);waitForAsyncReadComplete();</span>
<span class="pc bpc" id="L264" title="4 of 10 branches missed.">                __CLR4_4_1531531kylvdzxb.R.inc(6694);if ((((!readAheadBuffer.hasRemaining())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6695)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6696)==0&amp;false))) {{</span>
                    // The first read.
<span class="fc" id="L266">                    __CLR4_4_1531531kylvdzxb.R.inc(6697);readAsync();</span>
<span class="fc" id="L267">                    __CLR4_4_1531531kylvdzxb.R.inc(6698);waitForAsyncReadComplete();</span>
<span class="pc bpc" id="L268" title="4 of 10 branches missed.">                    __CLR4_4_1531531kylvdzxb.R.inc(6699);if ((((isEndOfStream())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6700)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6701)==0&amp;false))) {{</span>
<span class="fc" id="L269">                        __CLR4_4_1531531kylvdzxb.R.inc(6702);return EOF;</span>
                    }
                }}
                // Swap the newly read read ahead buffer in place of empty active buffer.
<span class="fc" id="L273">                }__CLR4_4_1531531kylvdzxb.R.inc(6703);swapBuffers();</span>
                // After swapping buffers, trigger another async read for read ahead buffer.
<span class="fc" id="L275">                __CLR4_4_1531531kylvdzxb.R.inc(6704);readAsync();</span>
            } finally {
<span class="fc" id="L277">                __CLR4_4_1531531kylvdzxb.R.inc(6705);stateChangeLock.unlock();</span>
            }
        }
<span class="fc" id="L280">        }__CLR4_4_1531531kylvdzxb.R.inc(6706);len = Math.min(len, activeBuffer.remaining());</span>
<span class="fc" id="L281">        __CLR4_4_1531531kylvdzxb.R.inc(6707);activeBuffer.get(b, offset, len);</span>

<span class="fc" id="L283">        __CLR4_4_1531531kylvdzxb.R.inc(6708);return len;</span>
<span class="fc" id="L284">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    /** Read data from underlyingInputStream to readAheadBuffer asynchronously. */
<span class="fc" id="L287">    private void readAsync() throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6709);</span>
<span class="fc" id="L288">        __CLR4_4_1531531kylvdzxb.R.inc(6710);stateChangeLock.lock();</span>
<span class="fc" id="L289">        __CLR4_4_1531531kylvdzxb.R.inc(6711);final byte[] arr;</span>
<span class="fc" id="L290">        __CLR4_4_1531531kylvdzxb.R.inc(6712);try {</span>
<span class="fc" id="L291">            __CLR4_4_1531531kylvdzxb.R.inc(6713);arr = readAheadBuffer.array();</span>
<span class="pc bpc" id="L292" title="5 of 12 branches missed.">            __CLR4_4_1531531kylvdzxb.R.inc(6714);if ((((endOfStream || readInProgress)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6715)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6716)==0&amp;false))) {{</span>
<span class="fc" id="L293">                __CLR4_4_1531531kylvdzxb.R.inc(6717);return;</span>
            }
<span class="fc" id="L295">            }__CLR4_4_1531531kylvdzxb.R.inc(6718);checkReadException();</span>
<span class="fc" id="L296">            __CLR4_4_1531531kylvdzxb.R.inc(6719);readAheadBuffer.position(0);</span>
<span class="fc" id="L297">            __CLR4_4_1531531kylvdzxb.R.inc(6720);readAheadBuffer.flip();</span>
<span class="fc" id="L298">            __CLR4_4_1531531kylvdzxb.R.inc(6721);readInProgress = true;</span>
        } finally {
<span class="fc" id="L300">            __CLR4_4_1531531kylvdzxb.R.inc(6722);stateChangeLock.unlock();</span>
        }
<span class="fc" id="L302">        __CLR4_4_1531531kylvdzxb.R.inc(6723);executorService.execute(() -&gt; {</span>
<span class="fc" id="L303">            __CLR4_4_1531531kylvdzxb.R.inc(6724);stateChangeLock.lock();</span>
<span class="fc" id="L304">            __CLR4_4_1531531kylvdzxb.R.inc(6725);try {</span>
<span class="pc bpc" id="L305" title="7 of 10 branches missed.">                __CLR4_4_1531531kylvdzxb.R.inc(6726);if ((((isClosed)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6727)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6728)==0&amp;false))) {{</span>
<span class="nc" id="L306">                    __CLR4_4_1531531kylvdzxb.R.inc(6729);readInProgress = false;</span>
<span class="nc" id="L307">                    __CLR4_4_1531531kylvdzxb.R.inc(6730);return;</span>
                }
                // Flip this so that the close method will not close the underlying input stream when we
                // are reading.
<span class="fc" id="L311">                }__CLR4_4_1531531kylvdzxb.R.inc(6731);isReading = true;</span>
            } finally {
<span class="fc" id="L313">                __CLR4_4_1531531kylvdzxb.R.inc(6732);stateChangeLock.unlock();</span>
            }

            // Please note that it is safe to release the lock and read into the read ahead buffer
            // because either of following two conditions will hold:
            //
            // 1. The active buffer has data available to read so the reader will not read from the read ahead buffer.
            //
            // 2. This is the first time read is called or the active buffer is exhausted, in that case the reader waits
            // for this async read to complete.
            //
            // So there is no race condition in both the situations.
<span class="fc" id="L325">            __CLR4_4_1531531kylvdzxb.R.inc(6733);int read = 0;</span>
<span class="fc" id="L326">            __CLR4_4_1531531kylvdzxb.R.inc(6734);int off = 0, len = arr.length;</span>
<span class="fc" id="L327">            __CLR4_4_1531531kylvdzxb.R.inc(6735);Throwable exception = null;</span>
<span class="fc" id="L328">            __CLR4_4_1531531kylvdzxb.R.inc(6736);try {</span>
                // try to fill the read ahead buffer.
                // if a reader is waiting, possibly return early.
<span class="fc" id="L331">                __CLR4_4_1531531kylvdzxb.R.inc(6737);do {{</span>
<span class="fc" id="L332">                    __CLR4_4_1531531kylvdzxb.R.inc(6738);read = underlyingInputStream.read(arr, off, len);</span>
<span class="pc bpc" id="L333" title="4 of 10 branches missed.">                    __CLR4_4_1531531kylvdzxb.R.inc(6739);if ((((read &lt;= 0)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6740)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6741)==0&amp;false))) {{</span>
<span class="fc" id="L334">                        __CLR4_4_1531531kylvdzxb.R.inc(6742);break;</span>
                    }
<span class="fc" id="L336">                    }__CLR4_4_1531531kylvdzxb.R.inc(6743);off += read;</span>
<span class="fc" id="L337">                    __CLR4_4_1531531kylvdzxb.R.inc(6744);len -= read;</span>
<span class="pc bpc" id="L338" title="4 of 12 branches missed.">                } }while ((((len &gt; 0 &amp;&amp; !isWaiting.get())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6745)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6746)==0&amp;false)));</span>
<span class="nc" id="L339">            } catch (final Throwable ex) {</span>
<span class="nc" id="L340">                __CLR4_4_1531531kylvdzxb.R.inc(6747);exception = ex;</span>
<span class="nc bnc" id="L341" title="All 10 branches missed.">                __CLR4_4_1531531kylvdzxb.R.inc(6748);if ((((ex instanceof Error)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6749)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6750)==0&amp;false))) {{</span>
                    // `readException` may not be reported to the user. Rethrow Error to make sure at least
                    // The user can see Error in UncaughtExceptionHandler.
<span class="nc" id="L344">                    __CLR4_4_1531531kylvdzxb.R.inc(6751);throw (Error) ex;</span>
                }
            }} finally {
<span class="fc" id="L347">                __CLR4_4_1531531kylvdzxb.R.inc(6752);stateChangeLock.lock();</span>
<span class="fc" id="L348">                __CLR4_4_1531531kylvdzxb.R.inc(6753);try {</span>
<span class="fc" id="L349">                    __CLR4_4_1531531kylvdzxb.R.inc(6754);readAheadBuffer.limit(off);</span>
<span class="pc bpc" id="L350" title="5 of 12 branches missed.">                    __CLR4_4_1531531kylvdzxb.R.inc(6755);if ((((read &lt; 0 || (exception instanceof EOFException))&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6756)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6757)==0&amp;false))) {{</span>
<span class="fc" id="L351">                        __CLR4_4_1531531kylvdzxb.R.inc(6758);endOfStream = true;</span>
<span class="pc bpc" id="L352" title="7 of 10 branches missed.">                    } }else {__CLR4_4_1531531kylvdzxb.R.inc(6759);if ((((exception != null)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6760)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6761)==0&amp;false))) {{</span>
<span class="nc" id="L353">                        __CLR4_4_1531531kylvdzxb.R.inc(6762);readAborted = true;</span>
<span class="nc" id="L354">                        __CLR4_4_1531531kylvdzxb.R.inc(6763);readException = exception;</span>
                    }
<span class="fc" id="L356">                    }}__CLR4_4_1531531kylvdzxb.R.inc(6764);readInProgress = false;</span>
<span class="fc" id="L357">                    __CLR4_4_1531531kylvdzxb.R.inc(6765);signalAsyncReadComplete();</span>
                } finally {
<span class="fc" id="L359">                    __CLR4_4_1531531kylvdzxb.R.inc(6766);stateChangeLock.unlock();</span>
                }
<span class="fc" id="L361">                __CLR4_4_1531531kylvdzxb.R.inc(6767);closeUnderlyingInputStreamIfNecessary();</span>
            }
<span class="fc" id="L363">        });</span>
<span class="fc" id="L364">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

<span class="fc" id="L366">    private void signalAsyncReadComplete() {try{__CLR4_4_1531531kylvdzxb.R.inc(6768);</span>
<span class="fc" id="L367">        __CLR4_4_1531531kylvdzxb.R.inc(6769);stateChangeLock.lock();</span>
<span class="fc" id="L368">        __CLR4_4_1531531kylvdzxb.R.inc(6770);try {</span>
<span class="fc" id="L369">            __CLR4_4_1531531kylvdzxb.R.inc(6771);asyncReadComplete.signalAll();</span>
        } finally {
<span class="fc" id="L371">            __CLR4_4_1531531kylvdzxb.R.inc(6772);stateChangeLock.unlock();</span>
        }
<span class="fc" id="L373">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    @Override
<span class="fc" id="L376">    public long skip(final long n) throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6773);</span>
<span class="pc bpc" id="L377" title="4 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6774);if ((((n &lt;= 0L)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6775)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6776)==0&amp;false))) {{</span>
<span class="fc" id="L378">            __CLR4_4_1531531kylvdzxb.R.inc(6777);return 0L;</span>
        }
<span class="pc bpc" id="L380" title="4 of 10 branches missed.">        }__CLR4_4_1531531kylvdzxb.R.inc(6778);if ((((n &lt;= activeBuffer.remaining())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6779)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6780)==0&amp;false))) {{</span>
            // Only skipping from active buffer is sufficient
<span class="fc" id="L382">            __CLR4_4_1531531kylvdzxb.R.inc(6781);activeBuffer.position((int) n + activeBuffer.position());</span>
<span class="fc" id="L383">            __CLR4_4_1531531kylvdzxb.R.inc(6782);return n;</span>
        }
<span class="fc" id="L385">        }__CLR4_4_1531531kylvdzxb.R.inc(6783);stateChangeLock.lock();</span>
<span class="fc" id="L386">        __CLR4_4_1531531kylvdzxb.R.inc(6784);long skipped;</span>
<span class="fc" id="L387">        __CLR4_4_1531531kylvdzxb.R.inc(6785);try {</span>
<span class="fc" id="L388">            __CLR4_4_1531531kylvdzxb.R.inc(6786);skipped = skipInternal(n);</span>
        } finally {
<span class="fc" id="L390">            __CLR4_4_1531531kylvdzxb.R.inc(6787);stateChangeLock.unlock();</span>
        }
<span class="fc" id="L392">        __CLR4_4_1531531kylvdzxb.R.inc(6788);return skipped;</span>
<span class="fc" id="L393">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    /**
     * Internal skip function which should be called only from skip(). The assumption is that the stateChangeLock is
     * already acquired in the caller before calling this function.
     *
     * @param n the number of bytes to be skipped.
     * @return the actual number of bytes skipped.
     */
<span class="fc" id="L402">    private long skipInternal(final long n) throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6789);</span>
<span class="pc bpc" id="L403" title="8 of 12 branches missed.">        assert (((stateChangeLock.isLocked())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6790)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6791)==0&amp;false));</span>
<span class="fc" id="L404">        __CLR4_4_1531531kylvdzxb.R.inc(6792);waitForAsyncReadComplete();</span>
<span class="pc bpc" id="L405" title="7 of 10 branches missed.">        __CLR4_4_1531531kylvdzxb.R.inc(6793);if ((((isEndOfStream())&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6794)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6795)==0&amp;false))) {{</span>
<span class="nc" id="L406">            __CLR4_4_1531531kylvdzxb.R.inc(6796);return 0;</span>
        }
<span class="pc bpc" id="L408" title="4 of 10 branches missed.">        }__CLR4_4_1531531kylvdzxb.R.inc(6797);if ((((available() &gt;= n)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6798)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6799)==0&amp;false))) {{</span>
            // we can skip from the internal buffers
<span class="fc" id="L410">            __CLR4_4_1531531kylvdzxb.R.inc(6800);int toSkip = (int) n;</span>
            // We need to skip from both active buffer and read ahead buffer
<span class="fc" id="L412">            __CLR4_4_1531531kylvdzxb.R.inc(6801);toSkip -= activeBuffer.remaining();</span>
<span class="pc bpc" id="L413" title="8 of 12 branches missed.">            assert (((toSkip &gt; 0)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6802)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6803)==0&amp;false)); // skipping from activeBuffer already handled.</span>
<span class="fc" id="L414">            __CLR4_4_1531531kylvdzxb.R.inc(6804);activeBuffer.position(0);</span>
<span class="fc" id="L415">            __CLR4_4_1531531kylvdzxb.R.inc(6805);activeBuffer.flip();</span>
<span class="fc" id="L416">            __CLR4_4_1531531kylvdzxb.R.inc(6806);readAheadBuffer.position(toSkip + readAheadBuffer.position());</span>
<span class="fc" id="L417">            __CLR4_4_1531531kylvdzxb.R.inc(6807);swapBuffers();</span>
            // Trigger async read to emptied read ahead buffer.
<span class="fc" id="L419">            __CLR4_4_1531531kylvdzxb.R.inc(6808);readAsync();</span>
<span class="fc" id="L420">            __CLR4_4_1531531kylvdzxb.R.inc(6809);return n;</span>
        }
<span class="fc" id="L422">        }__CLR4_4_1531531kylvdzxb.R.inc(6810);final int skippedBytes = available();</span>
<span class="fc" id="L423">        __CLR4_4_1531531kylvdzxb.R.inc(6811);final long toSkip = n - skippedBytes;</span>
<span class="fc" id="L424">        __CLR4_4_1531531kylvdzxb.R.inc(6812);activeBuffer.position(0);</span>
<span class="fc" id="L425">        __CLR4_4_1531531kylvdzxb.R.inc(6813);activeBuffer.flip();</span>
<span class="fc" id="L426">        __CLR4_4_1531531kylvdzxb.R.inc(6814);readAheadBuffer.position(0);</span>
<span class="fc" id="L427">        __CLR4_4_1531531kylvdzxb.R.inc(6815);readAheadBuffer.flip();</span>
<span class="fc" id="L428">        __CLR4_4_1531531kylvdzxb.R.inc(6816);final long skippedFromInputStream = underlyingInputStream.skip(toSkip);</span>
<span class="fc" id="L429">        __CLR4_4_1531531kylvdzxb.R.inc(6817);readAsync();</span>
<span class="fc" id="L430">        __CLR4_4_1531531kylvdzxb.R.inc(6818);return skippedBytes + skippedFromInputStream;</span>
<span class="fc" id="L431">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

    /**
     * Flips the active and read ahead buffer
     */
<span class="fc" id="L436">    private void swapBuffers() {try{__CLR4_4_1531531kylvdzxb.R.inc(6819);</span>
<span class="fc" id="L437">        __CLR4_4_1531531kylvdzxb.R.inc(6820);final ByteBuffer temp = activeBuffer;</span>
<span class="fc" id="L438">        __CLR4_4_1531531kylvdzxb.R.inc(6821);activeBuffer = readAheadBuffer;</span>
<span class="fc" id="L439">        __CLR4_4_1531531kylvdzxb.R.inc(6822);readAheadBuffer = temp;</span>
<span class="fc" id="L440">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>

<span class="fc" id="L442">    private void waitForAsyncReadComplete() throws IOException {try{__CLR4_4_1531531kylvdzxb.R.inc(6823);</span>
<span class="fc" id="L443">        __CLR4_4_1531531kylvdzxb.R.inc(6824);stateChangeLock.lock();</span>
<span class="fc" id="L444">        __CLR4_4_1531531kylvdzxb.R.inc(6825);try {</span>
<span class="fc" id="L445">            __CLR4_4_1531531kylvdzxb.R.inc(6826);isWaiting.set(true);</span>
            // There is only one reader, and one writer, so the writer should signal only once,
            // but a while loop checking the wake up condition is still needed to avoid spurious wakeups.
<span class="pc bpc" id="L448" title="4 of 10 branches missed.">            __CLR4_4_1531531kylvdzxb.R.inc(6827);while ((((readInProgress)&amp;&amp;(__CLR4_4_1531531kylvdzxb.R.iget(6828)!=0|true))||(__CLR4_4_1531531kylvdzxb.R.iget(6829)==0&amp;false))) {{</span>
<span class="fc" id="L449">                __CLR4_4_1531531kylvdzxb.R.inc(6830);asyncReadComplete.await();</span>
            }
<span class="nc" id="L451">        }} catch (final InterruptedException e) {</span>
<span class="nc" id="L452">            __CLR4_4_1531531kylvdzxb.R.inc(6831);final InterruptedIOException iio = new InterruptedIOException(e.getMessage());</span>
<span class="nc" id="L453">            __CLR4_4_1531531kylvdzxb.R.inc(6832);iio.initCause(e);</span>
<span class="nc" id="L454">            __CLR4_4_1531531kylvdzxb.R.inc(6833);throw iio;</span>
        } finally {
<span class="fc" id="L456">            __CLR4_4_1531531kylvdzxb.R.inc(6834);isWaiting.set(false);</span>
<span class="fc" id="L457">            __CLR4_4_1531531kylvdzxb.R.inc(6835);stateChangeLock.unlock();</span>
        }
<span class="fc" id="L459">        __CLR4_4_1531531kylvdzxb.R.inc(6836);checkReadException();</span>
<span class="fc" id="L460">    }finally{__CLR4_4_1531531kylvdzxb.R.flushNeeded();}}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>